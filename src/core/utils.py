# -*- coding: utf-8 -*-import os, statimport time# import subprocessfrom subprocess import callfrom subprocess import Popen, PIPEfrom datetime import datetimeimport magicimport multiprocessingfrom django.conf import settingsfrom django.utils.translation import ugettext_lazy as _from django.http import HttpResponseRedirectfrom django.core.urlresolvers import reversefrom django.shortcuts import get_object_or_404from gsi.settings import (EXECUTE_FE_COMMAND, PROCESS_NUM,						  STATIC_ROOT, STATIC_DIR)from core.multithreaded import MultiprocessingCardsclass UnicodeNameMixin(object):	def __unicode__(self):		return _(u"%s") % self.namedef validate_status(status):	from gsi.models import STATES	states = [st[0] for st in STATES]	if not status or status not in states:		return {			'status': False,			'message': 'Invalid or missing "status" GET parameter.'		}	return {'status': status}def execute_fe_command(params, flag='cards'):	queue = multiprocessing.JoinableQueue() # create queue of the tasks	num_process = len(params) / 2	# processes = PROCESS_NUM	processes = num_process	# print 'PARAMS =============== ', params	for param in params:		# print 'QUEUE PARAM =============== ', param		queue.put(param)	for i in xrange(processes):		t = MultiprocessingCards(queue, flag) # Create process		t.start()		time.sleep(0.1)	queue.join() # suspend the execution of code until the queue is emptied	# ***********************************************************************	# write log file	path_file = '/home/gsi/LOGS/execute_fe_command.log'	now = datetime.now()	log_api_file = open(path_file, 'a')	log_api_file.writelines('{0}\n'.format(now))	log_api_file.writelines('params = {0}:\n'.format(params))	log_api_file.writelines('params type = {0}:\n'.format(type(params)))	log_api_file.writelines('\n\n\n')	log_api_file.close()	# ***********************************************************************def slash_remove_from_path(path):	result = path	if '//' in path:		result = path.replace('//', '/')	elif '///' in path:		result = path.replace('///', '/')	return resultdef create_symlink(src, dest, path):	if not os.path.exists(path):		symlink = call("ln -s {0} {1}".format(dest, src), shell=True)	else:		passdef get_dir_root_static_path():	from gsi.models import HomeVariables	home_var = HomeVariables.objects.all()	user_dir_root = home_var[0].USER_DATA_DIR_ROOT	static_dir_root = user_dir_root.split('/')[-1]	if not static_dir_root:		static_dir_root = user_dir_root.split('/')[-2:-1]	static_dir_root_path = STATIC_DIR + '/' + static_dir_root[0]	static_dir_root_path = slash_remove_from_path(static_dir_root_path)	return {		'static_dir_root': static_dir_root[0],		'static_dir_root_path': static_dir_root_path,	}def convert_size_file(size):	kb = 1024.0	mb = 1024.0 * 1024.0	if size < kb:		size_file = "%.2f B" % (size)	if size > mb:		size = size / mb		size_file = "%.2f MB" % (size)	if size > kb:		size = float(size) / kb		size_file = "%.2f KB" % (size)	return size_filedef get_type_file(mime_type):	if mime_type[0] == 'image':		type_file = mime_type[0]	elif mime_type[0] == 'text':		type_file = mime_type[0]	elif mime_type[0] == 'application':		if mime_type[1] == 'pdf':			type_file = mime_type[1]		elif mime_type[1] == 'msword':			type_file = 'doc'		elif mime_type[1] == 'octet-stream':			type_file = 'bin'		else:			type_file = 'archive'	return type_filedef get_files_dirs(url_path, full_path):	dict_dirs = {}	all_dirs = {}	dict_files = {}	all_files = {}	info_message = False	try:		root, dirs, files = os.walk(full_path).next()		for d in dirs:			date_modification = datetime.fromtimestamp(os.path.getmtime(full_path))			format_date_modification = datetime.strftime(date_modification, "%Y/%m/%d %H:%M:%S")			dict_dirs['name'] = d			dict_dirs['date'] = format_date_modification			all_dirs[d] = dict_dirs			dict_dirs = {}		for f in files:			file_path = os.path.join(url_path, f)			full_file_path = os.path.join(full_path, f)			size_file = convert_size_file(os.path.getsize(full_file_path))			date_modification = datetime.fromtimestamp(os.path.getmtime(full_file_path))			format_date_modification = datetime.strftime(date_modification, "%Y/%m/%d %H:%M:%S")			mime_type = magic.from_file(full_file_path, mime=True)			type_file = get_type_file(mime_type.split('/'))			dict_files['name'] = f			dict_files['path'] = file_path			dict_files['size'] = size_file			dict_files['date'] = format_date_modification			dict_files['type'] = type_file			all_files[f] = dict_files			dict_files = {}	except StopIteration, e:		print 'StopIteration ===================== ', e		info_message = True	except OSError, e:		print 'OSError ===================== ', e		info_message = True	return all_dirs, all_files, info_messagedef create_sub_dir(path):	from gsi.models import HomeVariables	home_variables = HomeVariables.objects.all()	path_root = home_variables[0].USER_DATA_DIR_ROOT	sub_directories = ['Results', 'Scores', 'Trees']	try:		path_sub_directories = os.path.join(str(path_root), str(path))		try:			for dir in sub_directories:				full_path_sub_directories = os.path.join(str(path_sub_directories), str(dir))				os.makedirs(full_path_sub_directories)		except OSError, e:			print '*** FOLDER EXIST ***'	except Exception, e:		print 'ERROR create_sub_dir =================== ', edef create_new_folder(dir):	from gsi.models import HomeVariables as Home	home_var = Home.objects.all()	full_path = os.path.join(home_var[0].RF_AUXDATA_DIR, dir)	try:		os.makedirs(full_path)	except OSError, e:		print '*** FOLDER EXIST ***: ', e	return full_pathdef update_root_list_files():	from gsi.models import HomeVariables as Home	from gsi.models import ListTestFiles	home_var = Home.objects.all()	root_path = home_var[0].RF_AUXDATA_DIR	try:		root, dirs, files = os.walk(root_path).next()		tif_files = filter(lambda x: x.endswith('.tif'), files)		files_exclude = ListTestFiles.objects.filter(input_data_directory=None).exclude(name__in=tif_files).delete()		files_include = ListTestFiles.objects.filter(input_data_directory=None).values_list('name')		for f in tif_files:			file_path = os.path.join(root_path, f)			if (f,) not in files_include:				obj = ListTestFiles.objects.create(name=f, input_data_directory=None)				obj.size = convert_size_file(os.path.getsize(file_path))				obj.date_modified = datetime.fromtimestamp(os.path.getmtime(file_path))				obj.save()			# mime_type = magic.from_file(file_path, mime=True)			# if mime_type == 'image/tiff' and (f,) not in files_include:			#     obj = ListTestFiles.objects.create(name=f, input_data_directory=None)			#     obj.size = convert_size_file(os.path.getsize(file_path))			#     obj.date_modified = datetime.fromtimestamp(os.path.getmtime(file_path))			#     obj.save()	except StopIteration, e:		print 'StopIteration ===================== ', e	except OSError, e:		print 'OSError ===================== ', edef update_list_files(obj_dir):	from gsi.models import HomeVariables as Home	from gsi.models import ListTestFiles	update_list_dirs()	home_var = Home.objects.all()	root_path = home_var[0].RF_AUXDATA_DIR	if obj_dir is not None:		full_dir_path = os.path.join(obj_dir.full_path)	else:		full_dir_path = os.path.join(root_path)	try:		root, dirs, files = os.walk(full_dir_path).next()		tif_files = filter(lambda x: x.endswith('.tif'), files)		files_exclude = ListTestFiles.objects.filter(input_data_directory=obj_dir).exclude(name__in=tif_files).delete()		files_include = ListTestFiles.objects.filter(input_data_directory=obj_dir).values_list('name')		for f in tif_files:			full_file_path = os.path.join(full_dir_path, f)			if (f,) not in files_include:				obj = ListTestFiles.objects.create(name=f, input_data_directory=obj_dir)				file_path = os.path.join(full_dir_path, f)				obj.size = convert_size_file(os.path.getsize(file_path))				obj.date_modified = datetime.fromtimestamp(os.path.getmtime(file_path))				obj.save()			# mime_type = magic.from_file(full_file_path, mime=True)			#			# if mime_type == 'image/tiff' and (f,) not in files_include:			#     obj = ListTestFiles.objects.create(name=f, input_data_directory=obj_dir)			#     file_path = os.path.join(obj_dir.full_path, f)			#     obj.size = convert_size_file(os.path.getsize(file_path))			#     obj.date_modified = datetime.fromtimestamp(os.path.getmtime(file_path))			#     obj.save()	except StopIteration, e:		print 'StopIteration ===================== ', e	except OSError, e:		print 'OSError ===================== ', edef update_list_dirs():	from gsi.models import InputDataDirectory, ListTestFiles	from gsi.models import HomeVariables as Home	home_var = Home.objects.all()	root_path = home_var[0].RF_AUXDATA_DIR	all_dirs = InputDataDirectory.objects.all()	try:		for dir in all_dirs:			dir_path = os.path.join(root_path, dir.name)			if not os.path.exists(dir_path):				ListTestFiles.objects.filter(input_data_directory=dir).delete()				InputDataDirectory.objects.filter(name=dir.name).delete()	except OSError, e:		print 'OSError ===================== ', edef get_path_folder_run(run):	from gsi.models import HomeVariables as Home	home_var = Home.objects.all()	# home dir scripts	GSI_HOME = settings.SCRIPTS_HOME	path_runs_logs = GSI_HOME + 'scripts/runs/R_{0}/LOGS'.format(run.id)	return path_runs_logsdef make_run(run_base, user):	from gsi.models import Run, Log, RunStep, OrderedCardItem, SubCardItem	from gsi.models import HomeVariables as Home	now = datetime.now()	step = RunStep.objects.none()	scripts = []	first_script = {}	path_test_data = ''	run = Run.objects.create(run_base=run_base, user=user)	home_var = Home.objects.all()	resolution = run.run_base.resolution	directory_path = run.run_base.directory_path	all_card = OrderedCardItem.objects.filter(sequence__runbase=run.run_base).order_by('order')	try:		# <USER_DATA_DIR_ROOT>/<resolution>		path_test_data = home_var[0].USER_DATA_DIR_ROOT + '/' + str(resolution) + '/' + str(directory_path) + '/'		path_test_data = path_test_data.replace('//', '/')		try:			os.makedirs(path_test_data)			# ***********************************************************************			# write log file			# path_file = '/home/gsi/logs/0_make_dirs.log'			# now = datetime.now()			# log_file = open(path_file, 'a')			# log_file.writelines('{0}\n'.format(now))			# log_file.writelines('PATH TESTS: {0}\n\n\n'.format(path_test_data))			# log_file.close()			# ***********************************************************************		except OSError, e:			print '*** FOLDER EXIST ***'			# ***********************************************************************			# write log file			# path_file = '/home/gsi/logs/make_run_OSError.err'			# now = datetime.now()			# log_file = open(path_file, 'a')			# log_file.writelines('{0}\n'.format(now))			# log_file.writelines('PATH TESTS: {0}\n'.format(path_test_data))			# log_file.writelines('ERROR: {0}\n\n\n'.format(e))			# log_file.close()			# ***********************************************************************		finally:			try:				os.chmod(path_test_data, 0777)				os.umask(0000)			except Exception, e:				print '*** FOLDER ERROR *** :', e	except Exception, e:		# ***********************************************************************		# write log file		path_file = '/home/gsi/LOGS/make_run.err'		now = datetime.now()		log_file = open(path_file, 'a')		log_file.writelines('{0}\n'.format(now))		log_file.writelines('PATH TESTS: {0}\n'.format(path_test_data))		log_file.writelines('ERROR: {0}\n\n\n'.format(e))		log_file.close()		# ***********************************************************************	for card in all_card:		# ***********************************************************************		# write log file		# path_file = '/home/gsi/LOGS/make_run_cards.log'		# now = datetime.now()		# log_file = open(path_file, 'a')		# log_file.writelines('{0}\n'.format(now))		# log_file.writelines('CARDS: \n')		# log_file.writelines('CARD ==> {0}\n\n\n'.format(card))		# log_file.close()		# ***********************************************************************		step = RunStep.objects.create(parent_run=run, card_item=card)		#TODO: make scripts for each step		sequence = step.parent_run.run_base.card_sequence		script = create_scripts(run, sequence, card, step)		if not script:			run.delete()			step.delete()			return False		script['step'] = step		scripts.append(script)	if scripts:		first_script = scripts[0]		params = []		# ***********************************************************************		# write log file		path_file = '/home/gsi/LOGS/make_run_scripts.err'		now = datetime.now()		log_file = open(path_file, 'a')		log_file.writelines('{0}\n'.format(now))		log_file.writelines('SCRIPTS: \n')		log_file.writelines('name ==> {0}\n'.format(first_script['script_name']))		log_file.writelines('run ==> {0}\n'.format(first_script['run'].id))		# ***********************************************************************		try:			if first_script['card'].run_parallel:				sub_card_item = SubCardItem.objects.filter(									run_id=first_script['run'].id,									card_id=first_script['card'].id,									# state='pending'								).order_by('start_date')				# ***********************************************************************				log_file.writelines('LEN sub_card_item ==> {0}\n'.format(len(sub_card_item)))				# ***********************************************************************				for card in sub_card_item:					name_card = '{0}%{1}'.format(card.run_id, card.name)					params.append(name_card)					# card.state = 'running'					# card.save()					# ex_fe_com = Popen(					#     'nohup {0} {1} {2} &'.format(					#         EXECUTE_FE_COMMAND,					#         sub_card_item[0].run_id,					#         sub_card_item[0].name					#     ),					#     shell=True,					# )				first_script['step'].state = 'running'				first_script['step'].save()				first_script['run'].state = 'running'				first_script['run'].save()				execute_fe_command(params)			else:				ex_fe_com = Popen(				    'nohup {0} {1} {2} &'.format(				        EXECUTE_FE_COMMAND,				        first_script['run'].id,				        first_script['card'].id				    ),				    shell=True,				)				# first_script['step'].state = 'running'				# first_script['step'].save()				first_script['run'].state = 'running'				first_script['run'].save()		except Exception, e:			print 'ERROR ================== ', e			# ***********************************************************************			log_file.writelines('ERROR make run ==> {0}\n\n\n'.format(e))		log_file.close()		# ***********************************************************************		# print 'EXECUTE_FE_COMMAND ================ ', EXECUTE_FE_COMMAND		# print 'parent_run ================ ', first_script['run'].id		# print 'card_item ================ ', first_script['card'].id		log_name = '{0}_{1}.log'.format(run.id, first_script['card'].id)		path_log = first_script['path_runs_logs']		write_log(log_name, run, path_log)	return {'run': run, 'step': step}def create_scripts(run, sequence, card, step):	""" Create a script at startup run_base """	from gsi.models import HomeVariables as Home	# ***********************************************************************	# logs for api	# run, sequence, card, card_item	# path_file = '/home/gsi/LOGS/create_scripts.log'	# now = datetime.now()	# log_file = open(path_file, 'a')	# log_file.writelines('\n\n\nCREATE SCRIPT ==================\n')	# log_file.writelines(str(now) + '\n')	# log_file.writelines('RUN ==> {0}; ID ==> {1}\n'.format(run, run.id))	# log_file.writelines('RUN BASE ==> {0}; ID ==> {1}\n'.format(run.run_base, run.run_base.id))	# log_file.writelines('SEQUENCE ==> {0}; ID ==> {1}\n'.format(sequence, sequence.id))	# log_file.writelines('CARD ==> {0}; ID ==> {1}\n'.format(card, card.id))	# log_file.writelines('CARD ITEM ==> {0}; ID ==> {1}\n'.format(step.card_item.card_item, step.card_item.card_item.id))	# log_file.close()	# ***********************************************************************	home_var = Home.objects.all()	export_home_var = ''	# path_test_data = ''	LOCAL_VAR_GROUPS = ''	# directory_path = run.run_base.directory_path	# home dir scripts	GSI_HOME = settings.SCRIPTS_HOME	# <RESOLUTION_ENV_SCRIPT>	resolution = run.run_base.resolution	RESOLUTION_ENV_SCRIPT = GSI_HOME + 'bin/' + str(resolution) + '_config'	# <HOME_ENV_OVERRIDES>	for hv in home_var:		export_home_var += 'export SAT_TIF_DIR=' + hv.SAT_DIF_DIR_ROOT + '\n'		export_home_var += 'export RF_DIR=' + hv.RF_DIR_ROOT + '\n'		export_home_var += 'export USER_DATA_DIR=' + hv.USER_DATA_DIR_ROOT + '\n'		export_home_var += 'export MODIS_DIR=' + hv.MODIS_DIR_ROOT + '\n'		export_home_var += 'export RF_AUXDATA_DIR=' + hv.RF_AUXDATA_DIR + '\n'		export_home_var += 'export SAT_DIF_DIR=' + hv.SAT_DIF_DIR_ROOT	# <LOCAL_ENV_OVERRIDES>	# ***********************************************************************	# log_file.writelines('LOCAL VAR GROUP ==================\n')	# ***********************************************************************	try:		local_var_groups = (run.run_base.card_sequence.environment_base.environment_variables).replace('\r\n', '\n')		local_var_groups = local_var_groups.splitlines()		LOCAL_VAR_GROUPS = ''		for line in local_var_groups:			if line != '':				ln = line.replace('export ', '')				LOCAL_VAR_GROUPS += u'export {0}\n'.format(ln)		# ***********************************************************************		# log_file.writelines('LOCAL_VAR_GROUPS succes ==> {0}\n'.format(LOCAL_VAR_GROUPS))		# ***********************************************************************	except Exception, e:		LOCAL_VAR_GROUPS = ''		# ***********************************************************************		# log_file.writelines('LOCAL_VAR_GROUPS error ==> {0}\n'.format(e))		# ***********************************************************************	# <ENVIROMENT OVERRIDE>	# ***********************************************************************	# log_file.writelines('ENVIROMENT OVERRIDE ==================\n')	# ***********************************************************************	try:		env_override = (run.run_base.card_sequence.environment_override).replace('\r\n', '\n')		env_override = env_override.splitlines()		ENVIROMENT_OVERRIDE = ''		for line in env_override:			# ***********************************************************************			# log_file.writelines('ENVIROMENT_OVERRIDE LINE ==> {0}\n'.format(line))			# ***********************************************************************			if line != '':				ln = line.replace('export ', '')				ENVIROMENT_OVERRIDE += u'export {0}\n'.format(ln)		# ***********************************************************************		# log_file.writelines('ENVIROMENT_OVERRIDE succes ==> {0}\n'.format(ENVIROMENT_OVERRIDE))		# ***********************************************************************	except Exception, e:		ENVIROMENT_OVERRIDE = ''		# ***********************************************************************		# log_file.writelines('ENVIROMENT_OVERRIDE error ==> {0}\n'.format(e))		# ***********************************************************************	# <EXECUTABLE>	# ***********************************************************************	# log_file.writelines('EXECUTABLE ==================\n')	# ***********************************************************************	try:		card_item = step.card_item.card_item		run_parallel, EXECUTABLE = get_executable(run, sequence, card, card_item)		# ***********************************************************************		# print 'run_parallel create_scripts ======================= ', run_parallel		# log_file.writelines('EXECUTABLE succes ==> {0}\n'.format(EXECUTABLE))		# ***********************************************************************	except Exception, e:		print 'ERROR EXECUTABLE ======================= ', e		EXECUTABLE = ''		run_parallel = False		# ***********************************************************************		# log_file.writelines('EXECUTABLE error ==> {0}\n'.format(e))		# ***********************************************************************	# path to scripts for runs and steps	path_runs = GSI_HOME + 'scripts/runs/R_{0}/'.format(run.id)	path_runs_logs = GSI_HOME + 'scripts/runs/R_{0}/LOGS'.format(run.id)	# <USER_DATA_DIR_ROOT>/<resolution>	# ***********************************************************************	# write log file	# path_file = '/home/gsi/LOGS/user.log'	# now = datetime.now()	# log_file = open(path_file, 'a')	# log_file.writelines('{0}\n'.format(now))	# log_file.writelines('USER {0}\n'.format(os.getlogin()))	# ***********************************************************************	try:		os.makedirs(path_runs)		os.makedirs(path_runs_logs)		os.umask(0000)	except OSError, e:		print '*** FOLDER EXIST ***'		# ***********************************************************************		# log_file.writelines('ERROR {0}\n\n\n'.format(e))		# log_file.writelines('ERROR path_runs {0}\n\n\n'.format(path_runs))		# log_file.writelines('ERROR path_runs_logs {0}\n\n\n'.format(path_runs_logs))		# ***********************************************************************	finally:		try:			# import pdb;pdb.set_trace()			print 'MAKE RUN CARD ================== ', step.card_item			# print 'MAKE RUN PARALLEL ================== ', (not run_parallel)			if run_parallel:				print 'YES PARALLEL ================== ', run_parallel				params = []				for n in EXECUTABLE:					file_contents = ''					script_name = 'card_{0}.sh'.format(n)					script_path = path_runs + script_name					# print 'N ================== ', n					# print 'N TYPE ================== ', type(n)					# print 'EXECUTABLE ================== ', EXECUTABLE					# print 'EXECUTABLE N ================== ', EXECUTABLE[n]					file_contents += '# Sequence: {0}, card: {1} - Generated {2} \n\n'.\										format(sequence.name, card.card_item, step.start_date)					file_contents += 'umask 000'					file_contents += '. ' + RESOLUTION_ENV_SCRIPT + '\n\n'					file_contents += export_home_var + '\n\n'					file_contents += LOCAL_VAR_GROUPS + '\n\n'					file_contents += ENVIROMENT_OVERRIDE + '\n\n'					file_contents += EXECUTABLE[n]					fd = open(script_path, 'w+')					fd.write(file_contents)					# os.chmod(script_path, 0777)					# os.chmod(path_runs_logs, 0777)					fd.close()					# with open(script_path, 'w+') as f:					# 	f.write(file_contents)					# 	f.close()					os.chmod(script_path, 0777)					os.chmod(path_runs_logs, 0777)					os.umask(0000)					# fd.write('# Sequence: {0}, card: {1} - Generated {2} \n\n'.\					#          format(sequence.name, card.card_item, step.start_date))					# fd.writelines('. ' + RESOLUTION_ENV_SCRIPT + '\n\n')					# fd.writelines(export_home_var + '\n\n')					# fd.writelines(LOCAL_VAR_GROUPS + '\n\n')					# fd.writelines(ENVIROMENT_OVERRIDE + '\n\n')					# fd.writelines(EXECUTABLE[n])					#					# os.chmod(script_path, 0777)					# os.chmod(path_runs_logs, 0777)					# fd.close()				# 	param = '{0}%{1}%{2}'.format(script_path, path_runs_logs, file_contents)				# 	params.append(param)				# execute_fe_command(params, flag='file')			else:				print 'NOT PARALLEL ================== ', run_parallel				script_name = 'card_{0}.sh'.format(step.card_item.id)				script_path = path_runs + script_name				fd = open(script_path, 'w+')				fd.write('# Sequence: {0}, card: {1} - Generated {2} \n\n'.\						 format(sequence.name, card.card_item, step.start_date))				fd.writelines('. ' + RESOLUTION_ENV_SCRIPT + '\n\n')				fd.writelines(export_home_var + '\n\n')				fd.writelines(LOCAL_VAR_GROUPS + '\n\n')				fd.writelines(ENVIROMENT_OVERRIDE + '\n\n')				fd.writelines(EXECUTABLE)				os.chmod(script_path, 0777)				os.chmod(path_runs_logs, 0777)				os.umask(0000)				fd.close()				print 'NOT PARALLEL ================== ', run_parallel		except OSError, e:			pass			# ***********************************************************************			# log_file.writelines('OSError {0}\n\n\n'.format(e))			# ***********************************************************************			return False	# ***********************************************************************	# log_file.close()	# ***********************************************************************	return {		'script_path': script_path,		'path_runs_logs': path_runs_logs,		'script_name': script_name,		# 'card': card_item.id,		'run': run,		'card': card,	}def write_log(log_name, run, path_log):	from gsi.models import Log	log = Log.objects.create(name=log_name)	log.log_file_path = path_log	log.log_file = log_name	log.save()	run.log = log	run.save()def get_years(name):	from gsi.models import YearGroup	year_group = YearGroup.objects.get(name=name)	return year_group.years.through.objects.filter(yeargroup=year_group)def get_area_tiles(name):	from gsi.models import Area	card_area = Area.objects.get(name=name)	return card_area.tiles.through.objects.filter(area=card_area)def get_statistical_method(remap_obj):	stat_methods = []	if remap_obj.conditional_mean:		stat_methods.append('ConditionalMean')	if remap_obj.conditional_min:		stat_methods.append('ConditionalMin')	if remap_obj.conditional_median:		stat_methods.append('ConditionalMedian')	if remap_obj.conditional_max:		stat_methods.append('ConditionalMax')	if remap_obj.lower_quartile:		stat_methods.append('LowerQuartile')	if remap_obj.upper_quartile:		stat_methods.append('UpperQuartile')	return stat_methodsdef get_card_model(card_model, card_name):	from cards.models import (RFScore, RFTrain, QRF,							  Remap, YearFilter, PreProc,							  Collate, MergeCSV, RandomForest,							  CalcStats)	card = None	if card_model == 'rfscore':		card = RFScore.objects.get(name=card_name)	if card_model == 'rftrain':		card = RFTrain.objects.get(name=card_name)	if card_model == 'qrf':		card = QRF.objects.get(name=card_name)	if card_model == 'remap':		card = Remap.objects.get(name=card_name)	if card_model == 'yearfilter':		card = YearFilter.objects.get(name=card_name)	if card_model == 'preproc':		card = PreProc.objects.get(name=card_name)	if card_model == 'collate':		card = Collate.objects.get(name=card_name)	if card_model == 'randomforest':		card = RandomForest.objects.get(name=card_name)	if card_model == 'calcstats':		card = CalcStats.objects.get(name=card_name)	return carddef is_run_parallel(card):	run_parallel = False	try:		run_parallel = card.run_parallel	except Exception:		pass	return run_paralleldef create_sub_card_item(name, run_id, card_id):	from gsi.models import SubCardItem	try:		sub_card_item = SubCardItem.objects.create(				name=name,				run_id=run_id,				card_id=card_id		)	except Exception, e:		print 'ERROR sub card ======================== ', edef get_executable(run, sequence, card, card_item):	""" get the <EXECUTABLE> to script """	from cards.models import (RFScore, RFTrain, QRF,							  Remap, YearFilter, PreProc,							  Collate, MergeCSV, RandomForest,							  CalcStats)	from gsi.models import Year, Tile, ListTestFiles	card_model = card_item.content_type.model	# name_card = step.card_item.card_item.content_object	# run_parallel = False	# EXECUTABLE = ''	EXECUTABLE = ''	EXECUTABLE_DICT = {}	EXEC = ''	pid = 1	all_num = 1	run_parallel = False	# write log file	# path_file = '/home/gsi/LOGS/card_create_script.log'	# now = datetime.now()	# log_file = open(path_file, 'a')	# log_file.writelines('{0}\n'.format(now))	# log_file.writelines('CARD MODEL: {0}\n'.format(card_model))	# log_file.writelines('CARD NAME: {0}\n\n\n'.format(card.card_item.content_object))	# log_file.close()	if card_model == 'rfscore':		#  u'RFscore <Tile> [[MyDir]] [<BiasCorrn>] [<QRFopts>] [<RefTarget>] [<CleanName>]'		data_card = RFScore.objects.get(name=card.card_item.content_object)		years = get_years(data_card.year_group.name)		area_tiles = get_area_tiles(data_card.area)		all_num = len(years) * len(area_tiles)		run_parallel = is_run_parallel(data_card)		# write log file		# path_file = '/home/gsi/LOGS/rfscore_script.log'		# now = datetime.now()		# log_file = open(path_file, 'a')		# log_file.writelines('{0}\n'.format(now))		# log_file.writelines('CARD RFTrain: {0}\n'.format(card_model))		# log_file.writelines('NAME RFTrain: {0}\n\n\n'.format(card.card_item.content_object))		# log_file.writelines('--------------------')		#		# log_file.writelines('YEARS: {0}\n'.format(len(years)))		# log_file.writelines('AREAS: {0}\n'.format(len(area_tiles)))		# log_file.writelines('ALL NUM: {0}\n\n\n'.format(all_num))		# log_file.close()		for year in years:			year_card = Year.objects.get(id=year.year_id)			for tile in area_tiles:				tile_card = Tile.objects.get(id=tile.tile_id)				# print 'PID RFscore ====================== ', pid				if run_parallel:					EXEC = '$RF_EXEC_DIR/RFscore {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(						tile_card,						run.run_base.directory_path,						data_card.bias_corrn,						year_card,						data_card.number_of_threads,						data_card.QRFopts,						run.id,						sequence.id,						card.id,						pid,						all_num					)					script_name = '{0}_{1}'.format(card.id, pid)					EXECUTABLE_DICT[script_name] = EXEC					create_sub_card_item(script_name, run.id, card.id)					pid += 1				else:					EXECUTABLE += '$RF_EXEC_DIR/RFscore {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(						tile_card,						run.run_base.directory_path,						data_card.bias_corrn,						year_card,						data_card.number_of_threads,						data_card.QRFopts,						run.id,						sequence.id,						card.id,						pid,						all_num					)					pid += 1	if card_model == 'rftrain':		# u'RFtrain <Tile> [<Ntrees>] [<training>] [<Nvar>] [<Nthread>]'		data_card = RFTrain.objects.get(name=card.card_item.content_object)		# run_parallel = is_run_parallel(data_card)		# write log file		# path_file = '/home/gsi/LOGS/rftrain_script.log'		# now = datetime.now()		# log_file = open(path_file, 'a')		# log_file.writelines('{0}\n'.format(now))		# log_file.writelines('CARD RFTrain: {0}\n'.format(card_model))		# log_file.writelines('NAME RFTrain: {0}\n\n\n'.format(card.card_item.content_object))		# log_file.writelines('VALUE: {0}\n'.format(data_card.value))		# log_file.writelines('TREES: {0}\n'.format(data_card.number_of_trees))		# log_file.writelines('VARIABLE: {0}\n'.format(data_card.number_of_variable))		# log_file.writelines('TREAD: {0}\n'.format(data_card.number_of_thread))		# log_file.close()		EXECUTABLE += '$RF_EXEC_DIR/RFtrain {0} {1} {2} {3} {4} -s {5}.{6}.{7}.{8}.{9}\n'.format(							data_card.value,							data_card.number_of_trees,							data_card.training,							data_card.number_of_variable,							data_card.number_of_thread,							run.id,							sequence.id,							card.id,							pid,							1,						)		pid += 1	if card_model == 'qrf':		# u'QRF [<QRFinterval>] [<ntrees>] [<nthreads>] [<MyDir>]'		data_card = QRF.objects.get(name=card.card_item.content_object)		EXECUTABLE += '$RF_EXEC_DIR/QRF {0} {1} {2} {3} -s {4}.{5}.{6}.{7}.{8}\n'.format(							data_card.interval,							data_card.number_of_trees,							data_card.number_of_threads,							data_card.directory,							run.id,							sequence.id,							card.id,							pid,							1,						)		pid += 1	if card_model == 'remap':		# import pdb;pdb.set_trace()		# print 'remap =================== '		# u'Remap <FileSpec> <RoI> <OutRoot>[,<OutSuffix>] [<ColourTable>] [<RefStatsFile>] [<RefStatsScale>]'		# Remap <FileSpec> <RoI> <OutRoot>[,<OutSuffix>] [<Scale>[,<Xsize>,<Ysize>]] [<Output>] [<ColourTable>] [<RefStatsFile>] [<RefStatsScale>]		years = None		data_card = Remap.objects.get(name=card.card_item.content_object)		# print 'data_card =================== ', data_card		stat_methods = get_statistical_method(data_card)		# print 'stat_methods =================== ', stat_methods		run_parallel = is_run_parallel(data_card)		# print 'remap run_parallel ====================== ', run_parallel		model_name_suff = ''		file_spec = data_card.file_spec		output_root = data_card.output_root		refstats_scale = data_card.refstats_scale or ''		all_num = 1		if data_card.model_name and data_card.output_suffix:			model_name_suff = str(data_card.model_name) + data_card.output_suffix + '.tif'		if data_card.model_name and not data_card.output_suffix:			model_name_suff = str(data_card.model_name) + '.tif'		if not data_card.model_name and data_card.output_suffix:			model_name_suff = data_card.output_suffix + '.tif'		if data_card.year_group is not None:			years = get_years(data_card.year_group.name)		if years is not None:			years_num = len(years) or 1			methods_num = len(stat_methods) or 1			all_num = years_num * methods_num			for year in years:				year_card = Year.objects.get(id=year.year_id)				if stat_methods:					for m in stat_methods:						if model_name_suff:							method_file_spec = str(year_card) + '_' + m + '_' + model_name_suff						else:							method_file_spec = str(year_card) + '_' + m						method = str(year_card) + '_' + m						cur_file_spec = os.path.join(str(file_spec), "Scores", method_file_spec)						cur_output_root = os.path.join(str(output_root), method)						if run_parallel:							# print 'remap parrallel =============================='							EXEC = '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(								cur_file_spec,								data_card.roi,								cur_output_root,								# data_card.output_suffix,								data_card.scale,								data_card.output,								data_card.color_table,								data_card.refstats_file,								refstats_scale,								run.id,								sequence.id,								card.id,								pid,								all_num,							)							script_name = '{0}_{1}'.format(card.id, pid)							EXECUTABLE_DICT[script_name] = EXEC							create_sub_card_item(script_name, run.id, card.id)							pid += 1						else:							EXECUTABLE += '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(								cur_file_spec,								data_card.roi,								cur_output_root,								# data_card.output_suffix,								data_card.scale,								data_card.output,								data_card.color_table,								data_card.refstats_file,								refstats_scale,								run.id,								sequence.id,								card.id,								pid,								all_num,							)							pid += 1				else:					if model_name_suff:						full_path = str(year_card) + '_' + model_name_suff						cur_file_spec = os.path.join(str(file_spec), "Scores", full_path)					else:						cur_file_spec = os.path.join(str(file_spec), "Scores", str(year_card))					cur_output_root = os.path.join(str(output_root), str(year_card))					if run_parallel:						EXEC = '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(							cur_file_spec,							data_card.roi,							cur_output_root,							# data_card.output_suffix,							data_card.scale,							data_card.output,							data_card.color_table,							data_card.refstats_file,							refstats_scale,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						script_name = '{0}_{1}'.format(card.id, pid)						EXECUTABLE_DICT[script_name] = EXEC						create_sub_card_item(script_name, run.id, card.id)						pid += 1					else:						EXECUTABLE += '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(							cur_file_spec,							data_card.roi,							cur_output_root,							# data_card.output_suffix,							data_card.scale,							data_card.output,							data_card.color_table,							data_card.refstats_file,							refstats_scale,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						pid += 1		else:			if stat_methods:				all_num = len(stat_methods)				for m in stat_methods:					if model_name_suff:						full_path = m + '_' + model_name_suff						cur_file_spec = os.path.join(str(file_spec), "Scores", full_path)					else:						cur_file_spec = os.path.join(str(file_spec), "Scores", m)					cur_output_root = os.path.join(str(output_root), m)					if run_parallel:						EXEC = '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(							cur_file_spec,							data_card.roi,							cur_output_root,							# data_card.output_suffix,							data_card.scale,							data_card.output,							data_card.color_table,							data_card.refstats_file,							refstats_scale,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						script_name = '{0}_{1}'.format(card.id, pid)						EXECUTABLE_DICT[script_name] = EXEC						create_sub_card_item(script_name, run.id, card.id)						pid += 1					else:						EXECUTABLE += '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(							cur_file_spec,							data_card.roi,							cur_output_root,							# data_card.output_suffix,							data_card.scale,							data_card.output,							data_card.color_table,							data_card.refstats_file,							refstats_scale,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						pid += 1			else:				if model_name_suff:					cur_file_spec = os.path.join(str(file_spec), "Scores", model_name_suff)				else:					cur_file_spec = os.path.join(str(file_spec), "Scores")				if run_parallel:					EXEC = '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(						cur_file_spec,						data_card.roi,						data_card.output_root,						# data_card.output_suffix,						data_card.scale,						data_card.output,						data_card.color_table,						data_card.refstats_file,						refstats_scale,						run.id,						sequence.id,						card.id,						pid,						1,					)					script_name = '{0}_{1}'.format(card.id, pid)					EXECUTABLE_DICT[script_name] = EXEC					create_sub_card_item(script_name, run.id, card.id)					pid += 1				else:					EXECUTABLE += '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(						cur_file_spec,						data_card.roi,						data_card.output_root,						# data_card.output_suffix,						data_card.scale,						data_card.output,						data_card.color_table,						data_card.refstats_file,						refstats_scale,						run.id,						sequence.id,						card.id,						pid,						1,					)					pid += 1	if card_model == 'yearfilter':		# u'YearFilter <Tile> <FileType> [<Filter>] [<FiltOut>] [<ExtendStart>] [<InpFourier>] [<OutDir>] [<InpDir>]'		data_card = YearFilter.objects.get(name=card.card_item.content_object)		area_tiles = get_area_tiles(data_card.area)		all_num = len(area_tiles)		run_parallel = is_run_parallel(data_card)		for tile in area_tiles:			tile_card = Tile.objects.get(id=tile.tile_id)			if run_parallel:				EXEC = '$RF_EXEC_DIR/YearFilter {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(					tile_card,					data_card.filetype,					data_card.filter,					data_card.filter_output,					data_card.extend_start,					data_card.input_fourier,					data_card.output_directory,					data_card.input_directory,					run.id,					sequence.id,					card.id,					pid,					all_num,				)				script_name = '{0}_{1}'.format(card.id, pid)				EXECUTABLE_DICT[script_name] = EXEC				create_sub_card_item(script_name, run.id, card.id)				pid += 1			else:				EXECUTABLE += '$RF_EXEC_DIR/YearFilter {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(					tile_card,					data_card.filetype,					data_card.filter,					data_card.filter_output,					data_card.extend_start,					data_card.input_fourier,					data_card.output_directory,					data_card.input_directory,					run.id,					sequence.id,					card.id,					pid,					all_num,				)				pid += 1	if card_model == 'preproc':		# print 'preproc ===================== '		# print 'preproc card ===================== ', card		# print 'preproc card ID ===================== ', card.id		# u'PreProc [<Tile>|<file.hdf>] [<Year>] [<Mode>]'		data_card = PreProc.objects.get(name=card.card_item.content_object)		years = get_years(data_card.year_group.name)		area_tiles = get_area_tiles(data_card.area)		run_parallel = is_run_parallel(data_card)		if years:			len_years = len(years)		else:			len_years = 1		if area_tiles:			len_area_tiles = len(area_tiles)		else:			len_area_tiles = 1		all_num = len_years * len_area_tiles		if run_parallel:			card.run_parallel = True			card.number_sub_cards = all_num			card.save()		if years and area_tiles:			for year in years:				year_card = Year.objects.get(id=year.year_id)				for tile in area_tiles:					tile_card = Tile.objects.get(id=tile.tile_id)					if run_parallel:						EXEC = '$RF_EXEC_DIR/PreProc {0} {1} {2} -s {3}.{4}.{5}.{6}.{7}\n'.format(							tile_card,							year_card,							data_card.mode,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						script_name = '{0}_{1}'.format(card.id, pid)						EXECUTABLE_DICT[script_name] = EXEC						create_sub_card_item(script_name, run.id, card.id)						pid += 1					else:						EXECUTABLE += '$RF_EXEC_DIR/PreProc {0} {1} {2} -s {3}.{4}.{5}.{6}.{7}\n'.format(							tile_card,							year_card,							data_card.mode,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						pid += 1		if years and not area_tiles:			if run_parallel:				EXEC = '$RF_EXEC_DIR/PreProc {0} {1} -s {2}.{3}.{4}.{5}.{6}\n'.format(					year_card,					data_card.mode,					run.id,					sequence.id,					card.id,					pid,					all_num,				)				script_name = '{0}_{1}'.format(card.id, pid)				EXECUTABLE_DICT[script_name] = EXEC				create_sub_card_item(script_name, run.id, card.id)				pid += 1			else:				EXECUTABLE += '$RF_EXEC_DIR/PreProc {0} {1} -s {2}.{3}.{4}.{5}.{6}\n'.format(					year_card,					data_card.mode,					run.id,					sequence.id,					card.id,					pid,					all_num,				)				pid += 1		elif area_tiles and not years:			for tile in area_tiles:				tile_card = Tile.objects.get(id=tile.tile_id)				if run_parallel:					EXEC = '$RF_EXEC_DIR/PreProc {0} {1} -s {2}.{3}.{4}.{5}.{6}\n'.format(						tile_card,						data_card.mode,						run.id,						sequence.id,						card.id,						pid,						all_num,					)					script_name = '{0}_{1}'.format(card.id, pid)					EXECUTABLE_DICT[script_name] = EXEC					create_sub_card_item(script_name, run.id, card.id)					pid += 1				else:					EXECUTABLE += '$RF_EXEC_DIR/PreProc {0} {1} -s {2}.{3}.{4}.{5}.{6}\n'.format(						tile_card,						data_card.mode,						run.id,						sequence.id,						card.id,						pid,						all_num,					)					pid += 1		else:			if run_parallel:				EXEC = '$RF_EXEC_DIR/PreProc {0} -s {1}.{2}.{3}.{4}.{5}\n'.format(					data_card.mode,					run.id,					sequence.id,					card.id,					pid,					all_num,				)				script_name = '{0}_{1}'.format(card.id, pid)				EXECUTABLE_DICT[script_name] = EXEC				create_sub_card_item(script_name, run.id, card.id)			else:				EXECUTABLE += '$RF_EXEC_DIR/PreProc {0} -s {1}.{2}.{3}.{4}.{5}\n'.format(					data_card.mode,					run.id,					sequence.id,					card.id,					pid,					all_num,				)		# write log file		# path_file = '/home/gsi/LOGS/preproc_script.log'		# now = datetime.now()		# log_file = open(path_file, 'a')		# log_file.writelines('{0}\n'.format(now))		# log_file.writelines('CARD PreProc: {0}\n'.format(card_model))		# log_file.writelines('NAME PreProc: {0}\n\n'.format(card.card_item.content_object))		# log_file.writelines('years PreProc: {0}\n\n'.format(years))		# log_file.writelines('EXECUTABLE: {0}\n\n\n'.format(EXECUTABLE))		# log_file.close()	if card_model == 'collate':		# u'Collate <Tile> [<Mode>] [<InpFile>] [<OutDirFile>] [<InpScale>]'		# os.path.join(obj_dir.full_path, f)		from gsi.models import HomeVariables as Home		home_var = Home.objects.all()		root_path = home_var[0].RF_AUXDATA_DIR		# write log file		# path_file = '/home/gsi/LOGS/collate_script.log'		# now = datetime.now()		# log_file = open(path_file, 'a')		# log_file.writelines('====== {0} ==================\n'.format(now))		# log_file.writelines('CARD Collate: {0}\n'.format(card_model))		# log_file.writelines('NAME Collate: {0}\n\n'.format(card.card_item.content_object))		#		files = []		data_card = Collate.objects.get(name=card.card_item.content_object)		area_tiles = get_area_tiles(data_card.area)		files_list = Collate.input_files.through.objects.filter(collate=data_card)		run_parallel = is_run_parallel(data_card)		#		# log_file.writelines('files_list Collate: {0}\n\n'.format(files_list))		#		all_num = len(area_tiles)		for f in files_list:			file_obj = ListTestFiles.objects.get(id=f.listtestfiles_id)			f_name = file_obj.name.split('.')			f_subdir = os.path.join(data_card.output_tile_subdir, f_name[0])			temp = [file_obj.name, f_subdir]			files.append(temp)		if files:			all_num *= len(files)		for tile in area_tiles:			tile_card = Tile.objects.get(id=tile.tile_id)			if files:				for f in files:					if run_parallel:						EXEC = '$RF_EXEC_DIR/Collate {0} {1} {2} {3} {4} -s {5}.{6}.{7}.{8}.{9}\n'.format(							tile_card,							data_card.mode,							f[0],							f[1],							data_card.input_scale_factor,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						script_name = '{0}_{1}'.format(card.id, pid)						EXECUTABLE_DICT[script_name] = EXEC						create_sub_card_item(script_name, run.id, card.id)						pid += 1					else:						EXECUTABLE += '$RF_EXEC_DIR/Collate {0} {1} {2} {3} {4} -s {5}.{6}.{7}.{8}.{9}\n'.format(							tile_card,							data_card.mode,							f[0],							f[1],							data_card.input_scale_factor,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						pid += 1			else:				if run_parallel:					EXEC = '$RF_EXEC_DIR/Collate {0} {1} {2} -s {3}.{4}.{5}.{6}.{7}\n'.format(						tile_card,						data_card.mode,						data_card.input_scale_factor,						run.id,						sequence.id,						card.id,						pid,						all_num,					)					script_name = '{0}_{1}'.format(card.id, pid)					EXECUTABLE_DICT[script_name] = EXEC					create_sub_card_item(script_name, run.id, card.id)					pid += 1				else:					EXECUTABLE += '$RF_EXEC_DIR/Collate {0} {1} {2} -s {3}.{4}.{5}.{6}.{7}\n'.format(						tile_card,						data_card.mode,						data_card.input_scale_factor,						run.id,						sequence.id,						card.id,						pid,						all_num,					)					pid += 1		# write log file		# path_file = '/home/gsi/LOGS/collate_script.log'		# now = datetime.now()		# log_file = open(path_file, 'a')		# log_file.writelines('{0}\n'.format(now))		# log_file.writelines('CARD Collate: {0}\n'.format(card_model))		# log_file.writelines('NAME Collate: {0}\n\n'.format(card.card_item.content_object))		# log_file.writelines('Collate area_tiles: {0}\n\n'.format(area_tiles))		# log_file.writelines('Collate files: {0}\n\n'.format(files))		# log_file.writelines('EXECUTABLE: {0}\n\n\n'.format(EXECUTABLE))		# log_file.close()	if card_model == 'randomforest':		# RunRandomForestModels.sh <AoI_Name> <Satellite> <ParamSet> <RunSet>		data_card = RandomForest.objects.get(name=card.card_item.content_object)		EXECUTABLE += 'export MODELDIR=/lustre/w23/mattgsi/satdata/RF/Projects/Models\n'		EXECUTABLE += 'export CSVFILE=/lustre/w23/mattgsi/satdata/RF/Projects/Lane/Data/ref/Model${0}.csv >> $MODELDIR/ParamSet_CSVbands.sh\n'.format(data_card.model)		EXECUTABLE += 'export MVRF_TOTAL={0} >> $MODELDIR/ParamSet_CSV"$XSET".sh\n'.format(data_card.mvrf)		EXECUTABLE += 'RunRandomForestModels.sh {0} {1} {2} {3} -s {4}.{5}.{6}.{7}.{8}\n'.format(			data_card.aoi_name,			data_card.satellite,			data_card.param_set,			data_card.run_set,			run.id,			sequence.id,			card.id,			pid,			1,		)		pid += 1		# print 'randomforest EXECUTABLE ================================ ', EXECUTABLE	if card_model == 'calcstats':		#CalcStats <Tile> [<Year>] [<Period>] [<Filter>] [<FiltOut>] [OutDir]		data_card = CalcStats.objects.get(name=card.card_item.content_object)		period = data_card.period		run_parallel = is_run_parallel(data_card)		if period == 'doy':			period = data_card.doy_variable		try:			years = get_years(data_card.year_group.name)			# years_num = len(years)		except Exception, e:			# print 'ERRROR ====================== ', e			years_num = 1			years = None		try:			areas = get_area_tiles(data_card.area.name)			# areas_num = len(areas)		except Exception, e:			# print 'ERRROR ====================== ', e			areas_num = 1			areas = None		if years and areas:			all_num = len(years) * len(areas)			print 'YEAR ======================= ', len(years)			print 'AREA ======================= ', len(areas)			print 'ALL ======================= ', all_num			for year in years:				year_card = Year.objects.get(id=year.year_id)				for area in areas:					# area_card = Area.objects.get(id=year.year_id)					area_card = Tile.objects.get(id=area.tile_id)					if run_parallel:						EXEC = '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} {6} -s {7}.{8}.{9}.{10}.{11}\n'.format(							# data_card.output_tile_subdir,							area_card,							year_card,							period,							data_card.filter,							data_card.filter_out,							data_card.input_fourier,							data_card.out_dir,							run.id,							sequence.id,							card.id,							pid,							all_num						)						script_name = '{0}_{1}'.format(card.id, pid)						EXECUTABLE_DICT[script_name] = EXEC						create_sub_card_item(script_name, run.id, card.id)						pid += 1					else:						EXECUTABLE += '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} {6} -s {7}.{8}.{9}.{10}.{11}\n'.format(							# data_card.output_tile_subdir,							area_card,							year_card,							period,							data_card.filter,							data_card.filter_out,							data_card.input_fourier,							data_card.out_dir,							run.id,							sequence.id,							card.id,							pid,							all_num						)						pid += 1		elif years and not areas:			all_num = len(years)			for year in years:				year_card = Year.objects.get(id=year.year_id)				if run_parallel:					EXEC = '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(						# data_card.output_tile_subdir,						year_card,						period,						data_card.filter,						data_card.filter_out,						data_card.input_fourier,						data_card.out_dir,						run.id,						sequence.id,						card.id,						pid,						all_num					)					script_name = '{0}_{1}'.format(card.id, pid)					EXECUTABLE_DICT[script_name] = EXEC					create_sub_card_item(script_name, run.id, card.id)					pid += 1				else:					EXECUTABLE += '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(						# data_card.output_tile_subdir,						year_card,						period,						data_card.filter,						data_card.filter_out,						data_card.input_fourier,						data_card.out_dir,						run.id,						sequence.id,						card.id,						pid,						all_num					)					pid += 1		elif not years and areas:			all_num = len(areas)			for area in areas:				area_card = Tile.objects.get(id=area.tile_id)				if run_parallel:					EXEC = '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(						# data_card.output_tile_subdir,						area_card,						period,						data_card.filter,						data_card.filter_out,						data_card.input_fourier,						data_card.out_dir,						run.id,						sequence.id,						card.id,						pid,						all_num					)					script_name = '{0}_{1}'.format(card.id, pid)					EXECUTABLE_DICT[script_name] = EXEC					create_sub_card_item(script_name, run.id, card.id)					pid += 1				else:					EXECUTABLE += '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(						# data_card.output_tile_subdir,						area_card,						period,						data_card.filter,						data_card.filter_out,						data_card.input_fourier,						data_card.out_dir,						run.id,						sequence.id,						card.id,						pid,						all_num					)					pid += 1		else:			if run_parallel:				EXEC = '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(					data_card.output_tile_subdir,					period,					data_card.filter,					data_card.filter_out,					data_card.input_fourier,					data_card.out_dir,					run.id,					sequence.id,					card.id,					pid,					all_num				)				script_name = '{0}_{1}'.format(card.id, pid)				EXECUTABLE_DICT[script_name] = EXEC				create_sub_card_item(script_name, run.id, card.id)				pid += 1			else:				EXECUTABLE += '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(					data_card.output_tile_subdir,					period,					data_card.filter,					data_card.filter_out,					data_card.input_fourier,					data_card.out_dir,					run.id,					sequence.id,					card.id,					pid,					all_num				)				pid += 1	# if card_model == 'mergecsv':	#     # MergeCSV <PathSpec>/<FileSpec> [<OutFile>] [<Scale>]	#     data_card = MergeCSV.objects.get(name=card)	#     EXECUTABLE += '$RF_EXEC_DIR/MergeCSV {0} {1} {2} -s {3}.{4}.{5}\n'.format(	#         run.id,	#         card_item.id,	#         pid,	#     )	# print 'EXECUTABLE ================================ ', EXECUTABLE	# print 'EXECUTABLE_DICT ================================ ', EXECUTABLE_DICT	if run_parallel:		card.run_parallel = True		card.number_sub_cards = all_num	elif not run_parallel:		card.run_parallel = False		card.number_sub_cards = 0	card.save()	if run_parallel:		# print 'EXECUTABLE_DICT =================== ', EXECUTABLE_DICT		# print 'PARALLEL =================== ', run_parallel		return run_parallel, EXECUTABLE_DICT	else:		# print 'EXECUTABLE =================== ', EXECUTABLE		# print 'PARALLEL =================== ', run_parallel		return run_parallel, EXECUTABLE