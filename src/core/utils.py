# -*- coding: utf-8 -*-import os, stat# import subprocessfrom subprocess import callfrom subprocess import Popen, PIPEfrom datetime import datetimeimport magicfrom django.conf import settingsfrom django.utils.translation import ugettext_lazy as _from django.http import HttpResponseRedirectfrom django.core.urlresolvers import reversefrom django.shortcuts import get_object_or_404from gsi.settings import (EXECUTE_FE_COMMAND,                          STATIC_ROOT, STATIC_DIR)class UnicodeNameMixin(object):    def __unicode__(self):        return _(u"%s") % self.namedef validate_status(status):    from gsi.models import STATES    states = [st[0] for st in STATES]    if not status or status not in states:        return {            'status': False,            'message': 'Invalid or missing "status" GET parameter.'        }    return {'status': status}def slash_remove_from_path(path):    result = path    if '//' in path:        result = path.replace('//', '/')    elif '///' in path:        result = path.replace('///', '/')    return resultdef create_symlink(src, dest, path):    if not os.path.exists(path):        symlink = call("ln -s {0} {1}".format(dest, src), shell=True)    else:        passdef get_dir_root_static_path():    from gsi.models import HomeVariables    home_var = HomeVariables.objects.all()    user_dir_root = home_var[0].USER_DATA_DIR_ROOT    static_dir_root = user_dir_root.split('/')[-1]    if not static_dir_root:        static_dir_root = user_dir_root.split('/')[-2:-1]    static_dir_root_path = STATIC_DIR + '/' + static_dir_root[0]    static_dir_root_path = slash_remove_from_path(static_dir_root_path)    return {        'static_dir_root': static_dir_root[0],        'static_dir_root_path': static_dir_root_path,    }def convert_size_file(size):    kb = 1024.0    mb = 1024.0 * 1024.0    if size < kb:        size_file = "%.2f B" % (size)    if size > mb:        size = size / mb        size_file = "%.2f MB" % (size)    if size > kb:        size = float(size) / kb        size_file = "%.2f KB" % (size)    return size_filedef get_type_file(mime_type):    if mime_type[0] == 'image':        type_file = mime_type[0]    elif mime_type[0] == 'text':        type_file = mime_type[0]    elif mime_type[0] == 'application':        if mime_type[1] == 'pdf':            type_file = mime_type[1]        elif mime_type[1] == 'msword':            type_file = 'doc'        elif mime_type[1] == 'octet-stream':            type_file = 'bin'        else:            type_file = 'archive'    return type_filedef get_files_dirs(url_path, full_path):    dict_dirs = {}    all_dirs = {}    dict_files = {}    all_files = {}    info_message = False        try:        root, dirs, files = os.walk(full_path).next()        for d in dirs:            date_modification = datetime.fromtimestamp(os.path.getmtime(full_path))            format_date_modification = datetime.strftime(date_modification, "%Y/%m/%d %H:%M:%S")            dict_dirs['name'] = d            dict_dirs['date'] = format_date_modification            all_dirs[d] = dict_dirs            dict_dirs = {}        for f in files:            file_path = os.path.join(url_path, f)            full_file_path = os.path.join(full_path, f)            size_file = convert_size_file(os.path.getsize(full_file_path))            date_modification = datetime.fromtimestamp(os.path.getmtime(full_file_path))            format_date_modification = datetime.strftime(date_modification, "%Y/%m/%d %H:%M:%S")            mime_type = magic.from_file(full_file_path, mime=True)            type_file = get_type_file(mime_type.split('/'))            dict_files['name'] = f            dict_files['path'] = file_path            dict_files['size'] = size_file            dict_files['date'] = format_date_modification            dict_files['type'] = type_file            all_files[f] = dict_files            dict_files = {}    except StopIteration, e:        print 'StopIteration ===================== ', e        info_message = True    except OSError, e:        print 'OSError ===================== ', e        info_message = True    return all_dirs, all_files, info_messagedef create_sub_dir(path):    from gsi.models import HomeVariables    home_variables = HomeVariables.objects.all()    path_root = home_variables[0].USER_DATA_DIR_ROOT    sub_directories = ['Results', 'Scores', 'Trees']    try:        path_sub_directories = os.path.join(str(path_root), str(path))        try:            for dir in sub_directories:                full_path_sub_directories = os.path.join(str(path_sub_directories), str(dir))                os.makedirs(full_path_sub_directories)        except OSError, e:            print '*** FOLDER EXIST ***'    except Exception, e:        print 'ERROR create_sub_dir =================== ', edef create_new_folder(dir):    from gsi.models import HomeVariables as Home    home_var = Home.objects.all()    full_path = os.path.join(home_var[0].RF_AUXDATA_DIR, dir)    try:        os.makedirs(full_path)    except OSError, e:        print '*** FOLDER EXIST ***: ', e    return full_pathdef update_root_list_files():    from gsi.models import HomeVariables as Home    from gsi.models import ListTestFiles    home_var = Home.objects.all()    root_path = home_var[0].RF_AUXDATA_DIR    try:        root, dirs, files = os.walk(root_path).next()        tif_files = filter(lambda x: x.endswith('.tif'), files)        files_exclude = ListTestFiles.objects.filter(input_data_directory=None).exclude(name__in=tif_files).delete()        files_include = ListTestFiles.objects.filter(input_data_directory=None).values_list('name')        for f in tif_files:            file_path = os.path.join(root_path, f)            if (f,) not in files_include:                obj = ListTestFiles.objects.create(name=f, input_data_directory=None)                obj.size = convert_size_file(os.path.getsize(file_path))                obj.date_modified = datetime.fromtimestamp(os.path.getmtime(file_path))                obj.save()            # mime_type = magic.from_file(file_path, mime=True)            # if mime_type == 'image/tiff' and (f,) not in files_include:            #     obj = ListTestFiles.objects.create(name=f, input_data_directory=None)            #     obj.size = convert_size_file(os.path.getsize(file_path))            #     obj.date_modified = datetime.fromtimestamp(os.path.getmtime(file_path))            #     obj.save()    except StopIteration, e:        print 'StopIteration ===================== ', e    except OSError, e:        print 'OSError ===================== ', edef update_list_files(obj_dir):    from gsi.models import HomeVariables as Home    from gsi.models import ListTestFiles    update_list_dirs()    home_var = Home.objects.all()    root_path = home_var[0].RF_AUXDATA_DIR    if obj_dir is not None:        full_dir_path = os.path.join(obj_dir.full_path)    else:        full_dir_path = os.path.join(root_path)    try:        root, dirs, files = os.walk(full_dir_path).next()        tif_files = filter(lambda x: x.endswith('.tif'), files)        files_exclude = ListTestFiles.objects.filter(input_data_directory=obj_dir).exclude(name__in=tif_files).delete()        files_include = ListTestFiles.objects.filter(input_data_directory=obj_dir).values_list('name')        for f in tif_files:            full_file_path = os.path.join(full_dir_path, f)            if (f,) not in files_include:                obj = ListTestFiles.objects.create(name=f, input_data_directory=obj_dir)                file_path = os.path.join(full_dir_path, f)                obj.size = convert_size_file(os.path.getsize(file_path))                obj.date_modified = datetime.fromtimestamp(os.path.getmtime(file_path))                obj.save()            # mime_type = magic.from_file(full_file_path, mime=True)            #            # if mime_type == 'image/tiff' and (f,) not in files_include:            #     obj = ListTestFiles.objects.create(name=f, input_data_directory=obj_dir)            #     file_path = os.path.join(obj_dir.full_path, f)            #     obj.size = convert_size_file(os.path.getsize(file_path))            #     obj.date_modified = datetime.fromtimestamp(os.path.getmtime(file_path))            #     obj.save()    except StopIteration, e:        print 'StopIteration ===================== ', e    except OSError, e:        print 'OSError ===================== ', edef update_list_dirs():    from gsi.models import InputDataDirectory, ListTestFiles    from gsi.models import HomeVariables as Home    home_var = Home.objects.all()    root_path = home_var[0].RF_AUXDATA_DIR    all_dirs = InputDataDirectory.objects.all()    try:        for dir in all_dirs:            dir_path = os.path.join(root_path, dir.name)            if not os.path.exists(dir_path):                ListTestFiles.objects.filter(input_data_directory=dir).delete()                InputDataDirectory.objects.filter(name=dir.name).delete()    except OSError, e:        print 'OSError ===================== ', edef make_run(run_base, user):    from gsi.models import Run, Log, RunStep, OrderedCardItem, SubCardItem    from gsi.models import HomeVariables as Home    now = datetime.now()    step = RunStep.objects.none()    scripts = []    first_script = {}    path_test_data = ''    run = Run.objects.create(run_base=run_base, user=user)    home_var = Home.objects.all()    resolution = run.run_base.resolution    directory_path = run.run_base.directory_path    all_card = OrderedCardItem.objects.filter(sequence__runbase=run.run_base).order_by('order')    try:        # <USER_DATA_DIR_ROOT>/<resolution>        path_test_data = home_var[0].USER_DATA_DIR_ROOT + '/' + str(resolution) + '/' + str(directory_path) + '/'        path_test_data = path_test_data.replace('//', '/')        try:            os.makedirs(path_test_data)            # write log file            # path_file = '/home/gsi/logs/0_make_dirs.log'            # now = datetime.now()            # log_file = open(path_file, 'a')            # log_file.writelines('{0}\n'.format(now))            # log_file.writelines('PATH TESTS: {0}\n\n\n'.format(path_test_data))            # log_file.close()        except OSError, e:            print '*** FOLDER EXIST ***'            # write log file            # path_file = '/home/gsi/logs/make_run_OSError.err'            # now = datetime.now()            # log_file = open(path_file, 'a')            # log_file.writelines('{0}\n'.format(now))            # log_file.writelines('PATH TESTS: {0}\n'.format(path_test_data))            # log_file.writelines('ERROR: {0}\n\n\n'.format(e))            # log_file.close()        finally:            try:                os.chmod(path_test_data, 0777)            except Exception, e:                print '*** FOLDER ERROR *** :', e    except Exception, e:        # write log file        path_file = '/home/gsi/LOGS/make_run.err'        now = datetime.now()        log_file = open(path_file, 'a')        log_file.writelines('{0}\n'.format(now))        log_file.writelines('PATH TESTS: {0}\n'.format(path_test_data))        log_file.writelines('ERROR: {0}\n\n\n'.format(e))        log_file.close()    for card in all_card:        # write log file        path_file = '/home/gsi/LOGS/make_run_cards.log'        now = datetime.now()        log_file = open(path_file, 'a')        log_file.writelines('{0}\n'.format(now))        log_file.writelines('CARDS: \n')        log_file.writelines('CARD ==> {0}\n\n\n'.format(card))        log_file.close()        step = RunStep.objects.create(parent_run=run, card_item=card)        #TODO: make scripts for each step        sequence = step.parent_run.run_base.card_sequence        script = create_scripts(run, sequence, card, step)        if not script:            run.delete()            step.delete()            return False        script['step'] = step        scripts.append(script)    if scripts:        first_script = scripts[0]        # write log file        path_file = '/home/gsi/LOGS/make_run_scripts.log'        now = datetime.now()        log_file = open(path_file, 'a')        log_file.writelines('{0}\n'.format(now))        log_file.writelines('SCRIPTS: \n')        log_file.writelines('name ==> {0}\n'.format(first_script['script_name']))        log_file.writelines('run ==> {0}\n'.format(first_script['run'].id))        log_file.writelines('card ==> {0}\n\n\n'.format(first_script['card'].id))        log_file.close()        if first_script['card'].run_parallel:            sub_card_item = get_object_or_404(                    SubCardItem,                    run_id=first_script['run'].id,                    card_id=first_script['card'].id            )            for card in sub_card_item:                ex_fe_com = Popen(                    'nohup {0} {1} {2} &'.format(                        EXECUTE_FE_COMMAND,                        card.run_id,                        card.name                    ),                    shell=True,                )            sub_card_item.state = 'running'            sub_card_item.save()            # size = first_script['card'].number_sub_cards + 1            #            # for n in xrange(1, size):            #     name_script = '{0}_{1}'.format(first_script['card'].id, n)            #     ex_fe_com = Popen(            #         'nohup {0} {1} {2} &'.format(            #             EXECUTE_FE_COMMAND,            #             first_script['run'].id,            #             name_script            #         ),            #         shell=True,            #     )        else:            ex_fe_com = Popen(                'nohup {0} {1} {2} &'.format(                    EXECUTE_FE_COMMAND,                    first_script['run'].id,                    first_script['card'].id                ),                shell=True,            )            first_script['run'].state = 'running'        # print 'EXECUTE_FE_COMMAND ================ ', EXECUTE_FE_COMMAND        # print 'parent_run ================ ', first_script['run'].id        # print 'card_item ================ ', first_script['card'].id        log_name = '{0}_{1}.log'.format(run.id, first_script['card'].id)        path_log = first_script['path_runs_logs']        write_log(log_name, run, path_log)    return {'run': run, 'step': step}def create_scripts(run, sequence, card, step):    """ Create a script at startup run_base """    from gsi.models import HomeVariables as Home    # logs for api    # run, sequence, card, card_item    path_file = '/home/gsi/LOGS/create_scripts.log'    now = datetime.now()    log_file = open(path_file, 'a')    log_file.writelines('\n\n\nCREATE SCRIPT ==================\n')    log_file.writelines(str(now) + '\n')    log_file.writelines('RUN ==> {0}; ID ==> {1}\n'.format(run, run.id))    log_file.writelines('RUN BASE ==> {0}; ID ==> {1}\n'.format(run.run_base, run.run_base.id))    log_file.writelines('SEQUENCE ==> {0}; ID ==> {1}\n'.format(sequence, sequence.id))    log_file.writelines('CARD ==> {0}; ID ==> {1}\n'.format(card, card.id))    log_file.writelines('CARD ITEM ==> {0}; ID ==> {1}\n'.format(step.card_item.card_item, step.card_item.card_item.id))    # log_file.close()    home_var = Home.objects.all()    export_home_var = ''    # path_test_data = ''    LOCAL_VAR_GROUPS = ''    # directory_path = run.run_base.directory_path    # home dir scripts    GSI_HOME = settings.SCRIPTS_HOME    # <RESOLUTION_ENV_SCRIPT>    resolution = run.run_base.resolution    RESOLUTION_ENV_SCRIPT = GSI_HOME + 'bin/' + str(resolution) + '_config'    # <HOME_ENV_OVERRIDES>    for hv in home_var:        export_home_var += 'export SAT_TIF_DIR=' + hv.SAT_DIF_DIR_ROOT + '\n'        export_home_var += 'export RF_DIR=' + hv.RF_DIR_ROOT + '\n'        export_home_var += 'export USER_DATA_DIR=' + hv.USER_DATA_DIR_ROOT + '\n'        export_home_var += 'export MODIS_DIR=' + hv.MODIS_DIR_ROOT + '\n'        export_home_var += 'export RF_AUXDATA_DIR=' + hv.RF_AUXDATA_DIR + '\n'        export_home_var += 'export SAT_DIF_DIR=' + hv.SAT_DIF_DIR_ROOT    # <LOCAL_ENV_OVERRIDES>    log_file.writelines('LOCAL VAR GROUP ==================\n')    try:        local_var_groups = (run.run_base.card_sequence.environment_base.environment_variables).replace('\r\n', '\n')        local_var_groups = local_var_groups.splitlines()        LOCAL_VAR_GROUPS = ''        for line in local_var_groups:            if line != '':                ln = line.replace('export ', '')                LOCAL_VAR_GROUPS += u'export {0}\n'.format(ln)        log_file.writelines('LOCAL_VAR_GROUPS succes ==> {0}\n'.format(LOCAL_VAR_GROUPS))    except Exception, e:        LOCAL_VAR_GROUPS = ''        log_file.writelines('LOCAL_VAR_GROUPS error ==> {0}\n'.format(e))    # <ENVIROMENT OVERRIDE>    log_file.writelines('ENVIROMENT OVERRIDE ==================\n')    try:        env_override = (run.run_base.card_sequence.environment_override).replace('\r\n', '\n')        env_override = env_override.splitlines()        ENVIROMENT_OVERRIDE = ''        for line in env_override:            log_file.writelines('ENVIROMENT_OVERRIDE LINE ==> {0}\n'.format(line))            if line != '':                ln = line.replace('export ', '')                ENVIROMENT_OVERRIDE += u'export {0}\n'.format(ln)        log_file.writelines('ENVIROMENT_OVERRIDE succes ==> {0}\n'.format(ENVIROMENT_OVERRIDE))    except Exception, e:        ENVIROMENT_OVERRIDE = ''        log_file.writelines('ENVIROMENT_OVERRIDE error ==> {0}\n'.format(e))    # <EXECUTABLE>    log_file.writelines('EXECUTABLE ==================\n')    try:        card_item = step.card_item.card_item        run_parallel, EXECUTABLE = get_executable(run, sequence, card, card_item)        # print 'run_parallel create_scripts ======================= ', run_parallel        log_file.writelines('EXECUTABLE succes ==> {0}\n'.format(EXECUTABLE))    except Exception, e:        print 'ERROR EXECUTABLE ======================= ', e        EXECUTABLE = ''        run_parallel = False        log_file.writelines('EXECUTABLE error ==> {0}\n'.format(e))    # path to scripts for runs and steps    path_runs = GSI_HOME + 'scripts/runs/R_{0}/'.format(run.id)    path_runs_logs = GSI_HOME + 'scripts/runs/R_{0}/LOGS'.format(run.id)    # <USER_DATA_DIR_ROOT>/<resolution>    # write log file    path_file = '/home/gsi/LOGS/user.log'    now = datetime.now()    log_file = open(path_file, 'a')    log_file.writelines('{0}\n'.format(now))    log_file.writelines('USER {0}\n'.format(os.getlogin()))    try:        os.makedirs(path_runs)        os.makedirs(path_runs_logs)    except OSError, e:        print '*** FOLDER EXIST ***'        log_file.writelines('ERROR {0}\n\n\n'.format(e))        log_file.writelines('ERROR path_runs {0}\n\n\n'.format(path_runs))        log_file.writelines('ERROR path_runs_logs {0}\n\n\n'.format(path_runs_logs))    finally:        try:	        if not run_parallel:	            script_name = 'card_{0}.sh'.format(step.card_item.id)	            script_path = path_runs + script_name	            fd = open(script_path, 'w+')	            fd.write('# Sequence: {0}, card: {1} - Generated {2} \n\n'.\	                     format(sequence.name, card.card_item, step.start_date))	            fd.writelines('. ' + RESOLUTION_ENV_SCRIPT + '\n\n')	            fd.writelines(export_home_var + '\n\n')	            fd.writelines(LOCAL_VAR_GROUPS + '\n\n')	            fd.writelines(ENVIROMENT_OVERRIDE + '\n\n')	            fd.writelines(EXECUTABLE)	            os.chmod(script_path, 0777)	            os.chmod(path_runs_logs, 0777)	            fd.close()	        else:		        for n in EXECUTABLE:		            script_name = 'card_{0}.sh'.format(n)		            script_path = path_runs + script_name		            fd = open(script_path, 'w+')		            fd.write('# Sequence: {0}, card: {1} - Generated {2} \n\n'.\		                     format(sequence.name, card.card_item, step.start_date))		            fd.writelines('. ' + RESOLUTION_ENV_SCRIPT + '\n\n')		            fd.writelines(export_home_var + '\n\n')		            fd.writelines(LOCAL_VAR_GROUPS + '\n\n')		            fd.writelines(ENVIROMENT_OVERRIDE + '\n\n')		            fd.writelines(EXECUTABLE[n])		            os.chmod(script_path, 0777)		            os.chmod(path_runs_logs, 0777)		            fd.close()        except OSError, e:            log_file.writelines('OSError {0}\n\n\n'.format(e))            return False    log_file.close()    return {        'script_path': script_path,        'path_runs_logs': path_runs_logs,        'script_name': script_name,        # 'card': card_item.id,        'run': run,        'card': card,    }def write_log(log_name, run, path_log):    from gsi.models import Log    log = Log.objects.create(name=log_name)    log.log_file_path = path_log    log.log_file = log_name    log.save()    run.log = log    run.save()def get_years(name):    from gsi.models import YearGroup    year_group = YearGroup.objects.get(name=name)    return year_group.years.through.objects.filter(yeargroup=year_group)def get_area_tiles(name):    from gsi.models import Area    card_area = Area.objects.get(name=name)    return card_area.tiles.through.objects.filter(area=card_area)def get_statistical_method(remap_obj):    stat_methods = []    if remap_obj.conditional_mean:        stat_methods.append('ConditionalMean')    if remap_obj.conditional_min:        stat_methods.append('ConditionalMin')    if remap_obj.conditional_median:        stat_methods.append('ConditionalMedian')    if remap_obj.conditional_max:        stat_methods.append('ConditionalMax')    if remap_obj.lower_quartile:        stat_methods.append('LowerQuartile')    if remap_obj.upper_quartile:        stat_methods.append('UpperQuartile')    return stat_methodsdef get_card_model(card_model, card_name):	from cards.models import (RFScore, RFTrain, QRF,                              Remap, YearFilter, PreProc,                              Collate, MergeCSV, RandomForest,                              CalcStats)	card = None	if card_model == 'rfscore':		card = RFScore.objects.get(name=card_name)	if card_model == 'rftrain':		card = RFTrain.objects.get(name=card_name)	if card_model == 'qrf':		card = QRF.objects.get(name=card_name)	if card_model == 'remap':		card = Remap.objects.get(name=card_name)	if card_model == 'yearfilter':		card = YearFilter.objects.get(name=card_name)	if card_model == 'preproc':		card = PreProc.objects.get(name=card_name)	if card_model == 'collate':		card = Collate.objects.get(name=card_name)	if card_model == 'randomforest':		card = RandomForest.objects.get(name=card_name)	if card_model == 'calcstats':		card = CalcStats.objects.get(name=card_name)	return carddef is_run_parallel(card):    run_parallel = False    try:        run_parallel = card.run_parallel    except Exception:        pass    return run_paralleldef create_sub_card_item(name, run_id, card_id):    from gsi.models import SubCardItem    try:        sub_card_item = SubCardItem.objects.create(                name=name,                run_id=run_id,                card_id=card_id        )    except Exception, e:        print 'ERROR sub card ======================== ', edef get_executable(run, sequence, card, card_item):    """ get the <EXECUTABLE> to script """    from cards.models import (RFScore, RFTrain, QRF,                              Remap, YearFilter, PreProc,                              Collate, MergeCSV, RandomForest,                              CalcStats)    from gsi.models import Year, Tile, ListTestFiles    card_model = card_item.content_type.model    # name_card = step.card_item.card_item.content_object    # run_parallel = False    # EXECUTABLE = ''    EXECUTABLE = ''    EXECUTABLE_DICT = {}    EXEC = ''    pid = 1    all_num = 1    run_parallel = False    # write log file    path_file = '/home/gsi/LOGS/card_create_script.log'    now = datetime.now()    log_file = open(path_file, 'a')    log_file.writelines('{0}\n'.format(now))    log_file.writelines('CARD MODEL: {0}\n'.format(card_model))    log_file.writelines('CARD NAME: {0}\n\n\n'.format(card.card_item.content_object))    log_file.close()    if card_model == 'rfscore':        #  u'RFscore <Tile> [[MyDir]] [<BiasCorrn>] [<QRFopts>] [<RefTarget>] [<CleanName>]'        data_card = RFScore.objects.get(name=card.card_item.content_object)        years = get_years(data_card.year_group.name)        area_tiles = get_area_tiles(data_card.area)        all_num = len(years) * len(area_tiles)        run_parallel = is_run_parallel(data_card)        # write log file        # path_file = '/home/gsi/LOGS/rfscore_script.log'        # now = datetime.now()        # log_file = open(path_file, 'a')        # log_file.writelines('{0}\n'.format(now))        # log_file.writelines('CARD RFTrain: {0}\n'.format(card_model))        # log_file.writelines('NAME RFTrain: {0}\n\n\n'.format(card.card_item.content_object))        # log_file.writelines('--------------------')        #        # log_file.writelines('YEARS: {0}\n'.format(len(years)))        # log_file.writelines('AREAS: {0}\n'.format(len(area_tiles)))        # log_file.writelines('ALL NUM: {0}\n\n\n'.format(all_num))        # log_file.close()        for year in years:            year_card = Year.objects.get(id=year.year_id)            for tile in area_tiles:                tile_card = Tile.objects.get(id=tile.tile_id)                # print 'PID RFscore ====================== ', pid                if run_parallel:                    EXEC = '$RF_EXEC_DIR/RFscore {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(                        tile_card,                        run.run_base.directory_path,                        data_card.bias_corrn,                        year_card,                        data_card.number_of_threads,                        data_card.QRFopts,                        run.id,                        sequence.id,                        card.id,                        pid,                        all_num                    )                    script_name = '{0}_{1}'.format(card.id, pid)                    EXECUTABLE_DICT[script_name] = EXEC                    create_sub_card_item(script_name, run.id, card.id)                    pid += 1                else:                    EXECUTABLE += '$RF_EXEC_DIR/RFscore {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(                        tile_card,                        run.run_base.directory_path,                        data_card.bias_corrn,                        year_card,                        data_card.number_of_threads,                        data_card.QRFopts,                        run.id,                        sequence.id,                        card.id,                        pid,                        all_num                    )                    pid += 1    if card_model == 'rftrain':        # u'RFtrain <Tile> [<Ntrees>] [<training>] [<Nvar>] [<Nthread>]'        data_card = RFTrain.objects.get(name=card.card_item.content_object)        # run_parallel = is_run_parallel(data_card)        # write log file        # path_file = '/home/gsi/LOGS/rftrain_script.log'        # now = datetime.now()        # log_file = open(path_file, 'a')        # log_file.writelines('{0}\n'.format(now))        # log_file.writelines('CARD RFTrain: {0}\n'.format(card_model))        # log_file.writelines('NAME RFTrain: {0}\n\n\n'.format(card.card_item.content_object))        # log_file.writelines('VALUE: {0}\n'.format(data_card.value))        # log_file.writelines('TREES: {0}\n'.format(data_card.number_of_trees))        # log_file.writelines('VARIABLE: {0}\n'.format(data_card.number_of_variable))        # log_file.writelines('TREAD: {0}\n'.format(data_card.number_of_thread))        # log_file.close()        EXECUTABLE += '$RF_EXEC_DIR/RFtrain {0} {1} {2} {3} {4} -s {5}.{6}.{7}.{8}.{9}\n'.format(            data_card.value,            data_card.number_of_trees,            data_card.training,            data_card.number_of_variable,            data_card.number_of_thread,            run.id,            sequence.id,            card.id,            pid,            1,        )        pid += 1    if card_model == 'qrf':        # u'QRF [<QRFinterval>] [<ntrees>] [<nthreads>] [<MyDir>]'        data_card = QRF.objects.get(name=card.card_item.content_object)        EXECUTABLE += '$RF_EXEC_DIR/QRF {0} {1} {2} {3} -s {4}.{5}.{6}.{7}.{8}\n'.format(            data_card.interval,            data_card.number_of_trees,            data_card.number_of_threads,            data_card.directory,            run.id,            sequence.id,            card.id,            pid,            1,        )        pid += 1    if card_model == 'remap':        # import pdb;pdb.set_trace()        # print 'remap =================== '        # u'Remap <FileSpec> <RoI> <OutRoot>[,<OutSuffix>] [<ColourTable>] [<RefStatsFile>] [<RefStatsScale>]'        # Remap <FileSpec> <RoI> <OutRoot>[,<OutSuffix>] [<Scale>[,<Xsize>,<Ysize>]] [<Output>] [<ColourTable>] [<RefStatsFile>] [<RefStatsScale>]        years = None        data_card = Remap.objects.get(name=card.card_item.content_object)        # print 'data_card =================== ', data_card        stat_methods = get_statistical_method(data_card)        # print 'stat_methods =================== ', stat_methods        run_parallel = is_run_parallel(data_card)        # print 'remap run_parallel ====================== ', run_parallel        model_name_suff = ''        file_spec = data_card.file_spec        output_root = data_card.output_root        refstats_scale = data_card.refstats_scale or ''        all_num = 1        if data_card.model_name and data_card.output_suffix:            model_name_suff = str(data_card.model_name) + data_card.output_suffix + '.tif'        if data_card.model_name and not data_card.output_suffix:            model_name_suff = str(data_card.model_name) + '.tif'        if not data_card.model_name and data_card.output_suffix:            model_name_suff = data_card.output_suffix + '.tif'        if data_card.year_group is not None:            years = get_years(data_card.year_group.name)        if years is not None:            years_num = len(years) or 1            methods_num = len(stat_methods) or 1            all_num = years_num * methods_num            for year in years:                year_card = Year.objects.get(id=year.year_id)                if stat_methods:                    for m in stat_methods:                        if model_name_suff:                            method_file_spec = str(year_card) + '_' + m + '_' + model_name_suff                        else:                            method_file_spec = str(year_card) + '_' + m                        method = str(year_card) + '_' + m                        cur_file_spec = os.path.join(str(file_spec), "Scores", method_file_spec)                        cur_output_root = os.path.join(str(output_root), method)                        if run_parallel:	                        # print 'remap parrallel =============================='	                        EXEC = '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(                                cur_file_spec,                                data_card.roi,                                cur_output_root,                                # data_card.output_suffix,                                data_card.scale,                                data_card.output,                                data_card.color_table,                                data_card.refstats_file,                                refstats_scale,                                run.id,                                sequence.id,                                card.id,                                pid,                                all_num,                            )	                        script_name = '{0}_{1}'.format(card.id, pid)	                        EXECUTABLE_DICT[script_name] = EXEC	                        create_sub_card_item(script_name, run.id, card.id)	                        pid += 1                        else:	                        EXECUTABLE += '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(                                cur_file_spec,                                data_card.roi,                                cur_output_root,                                # data_card.output_suffix,                                data_card.scale,                                data_card.output,                                data_card.color_table,                                data_card.refstats_file,                                refstats_scale,                                run.id,                                sequence.id,                                card.id,                                pid,                                all_num,                            )	                        pid += 1                else:                    if model_name_suff:                        full_path = str(year_card) + '_' + model_name_suff                        cur_file_spec = os.path.join(str(file_spec), "Scores", full_path)                    else:                        cur_file_spec = os.path.join(str(file_spec), "Scores", str(year_card))                    cur_output_root = os.path.join(str(output_root), str(year_card))                    if run_parallel:                        EXEC = '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(                            cur_file_spec,                            data_card.roi,                            cur_output_root,                            # data_card.output_suffix,                            data_card.scale,                            data_card.output,                            data_card.color_table,                            data_card.refstats_file,                            refstats_scale,                            run.id,                            sequence.id,                            card.id,                            pid,                            all_num,                        )                        script_name = '{0}_{1}'.format(card.id, pid)                        EXECUTABLE_DICT[script_name] = EXEC                        create_sub_card_item(script_name, run.id, card.id)                        pid += 1                    else:                        EXECUTABLE += '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(                            cur_file_spec,                            data_card.roi,                            cur_output_root,                            # data_card.output_suffix,                            data_card.scale,                            data_card.output,                            data_card.color_table,                            data_card.refstats_file,                            refstats_scale,                            run.id,                            sequence.id,                            card.id,                            pid,                            all_num,                        )                        pid += 1        else:            if stat_methods:                all_num = len(stat_methods)                for m in stat_methods:                    if model_name_suff:                        full_path = m + '_' + model_name_suff                        cur_file_spec = os.path.join(str(file_spec), "Scores", full_path)                    else:                        cur_file_spec = os.path.join(str(file_spec), "Scores", m)                    cur_output_root = os.path.join(str(output_root), m)                    if run_parallel:                        EXEC = '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(                            cur_file_spec,                            data_card.roi,                            cur_output_root,                            # data_card.output_suffix,                            data_card.scale,                            data_card.output,                            data_card.color_table,                            data_card.refstats_file,                            refstats_scale,                            run.id,                            sequence.id,                            card.id,                            pid,                            all_num,                        )                        script_name = '{0}_{1}'.format(card.id, pid)                        EXECUTABLE_DICT[script_name] = EXEC                        create_sub_card_item(script_name, run.id, card.id)                        pid += 1                    else:                        EXECUTABLE += '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(                            cur_file_spec,                            data_card.roi,                            cur_output_root,                            # data_card.output_suffix,                            data_card.scale,                            data_card.output,                            data_card.color_table,                            data_card.refstats_file,                            refstats_scale,                            run.id,                            sequence.id,                            card.id,                            pid,                            all_num,                        )                        pid += 1            else:                if model_name_suff:                    cur_file_spec = os.path.join(str(file_spec), "Scores", model_name_suff)                else:                    cur_file_spec = os.path.join(str(file_spec), "Scores")                if run_parallel:                    EXEC = '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(                        cur_file_spec,                        data_card.roi,                        data_card.output_root,                        # data_card.output_suffix,                        data_card.scale,                        data_card.output,                        data_card.color_table,                        data_card.refstats_file,                        refstats_scale,                        run.id,                        sequence.id,                        card.id,                        pid,                        1,                    )                    script_name = '{0}_{1}'.format(card.id, pid)                    EXECUTABLE_DICT[script_name] = EXEC                    create_sub_card_item(script_name, run.id, card.id)                    pid += 1                else:                    EXECUTABLE += '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(                        cur_file_spec,                        data_card.roi,                        data_card.output_root,                        # data_card.output_suffix,                        data_card.scale,                        data_card.output,                        data_card.color_table,                        data_card.refstats_file,                        refstats_scale,                        run.id,                        sequence.id,                        card.id,                        pid,                        1,                    )                    pid += 1    if card_model == 'yearfilter':        # u'YearFilter <Tile> <FileType> [<Filter>] [<FiltOut>] [<ExtendStart>] [<InpFourier>] [<OutDir>] [<InpDir>]'        data_card = YearFilter.objects.get(name=card.card_item.content_object)        area_tiles = get_area_tiles(data_card.area)        all_num = len(area_tiles)        run_parallel = is_run_parallel(data_card)        for tile in area_tiles:            tile_card = Tile.objects.get(id=tile.tile_id)            if run_parallel:                EXEC = '$RF_EXEC_DIR/YearFilter {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(                    tile_card,                    data_card.filetype,                    data_card.filter,                    data_card.filter_output,                    data_card.extend_start,                    data_card.input_fourier,                    data_card.output_directory,                    data_card.input_directory,                    run.id,                    sequence.id,                    card.id,                    pid,                    all_num,                )                script_name = '{0}_{1}'.format(card.id, pid)                EXECUTABLE_DICT[script_name] = EXEC                create_sub_card_item(script_name, run.id, card.id)                pid += 1            else:                EXECUTABLE += '$RF_EXEC_DIR/YearFilter {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(                    tile_card,                    data_card.filetype,                    data_card.filter,                    data_card.filter_output,                    data_card.extend_start,                    data_card.input_fourier,                    data_card.output_directory,                    data_card.input_directory,                    run.id,                    sequence.id,                    card.id,                    pid,                    all_num,                )                pid += 1    if card_model == 'preproc':        # print 'preproc ===================== '        # print 'preproc card ===================== ', card        # print 'preproc card ID ===================== ', card.id        # u'PreProc [<Tile>|<file.hdf>] [<Year>] [<Mode>]'        data_card = PreProc.objects.get(name=card.card_item.content_object)        years = get_years(data_card.year_group.name)        area_tiles = get_area_tiles(data_card.area)        run_parallel = is_run_parallel(data_card)        if years:	        len_years = len(years)        else:	        len_years = 1        if area_tiles:	        len_area_tiles = len(area_tiles)        else:	        len_area_tiles = 1        all_num = len_years * len_area_tiles        if run_parallel:			card.run_parallel = True			card.number_sub_cards = all_num			card.save()        if years and area_tiles:	        for year in years:		        year_card = Year.objects.get(id=year.year_id)		        for tile in area_tiles:			        tile_card = Tile.objects.get(id=tile.tile_id)		                if run_parallel:			                EXEC = '$RF_EXEC_DIR/PreProc {0} {1} {2} -s {3}.{4}.{5}.{6}.{7}\n'.format(                                tile_card,                                year_card,                                data_card.mode,                                run.id,                                sequence.id,                                card.id,                                pid,                                all_num,                            )			                script_name = '{0}_{1}'.format(card.id, pid)			                EXECUTABLE_DICT[script_name] = EXEC			                create_sub_card_item(script_name, run.id, card.id)			                pid += 1		                else:			                EXECUTABLE += '$RF_EXEC_DIR/PreProc {0} {1} {2} -s {3}.{4}.{5}.{6}.{7}\n'.format(                                tile_card,                                year_card,                                data_card.mode,                                run.id,                                sequence.id,                                card.id,                                pid,                                all_num,                            )			                pid += 1		if years and not area_tiles:			if run_parallel:				EXEC = '$RF_EXEC_DIR/PreProc {0} {1} -s {2}.{3}.{4}.{5}.{6}\n'.format(                    year_card,                    data_card.mode,                    run.id,                    sequence.id,                    card.id,                    pid,                    all_num,                )		        script_name = '{0}_{1}'.format(card.id, pid)		        EXECUTABLE_DICT[script_name] = EXEC		        create_sub_card_item(script_name, run.id, card.id)		        pid += 1	        else:		        EXECUTABLE += '$RF_EXEC_DIR/PreProc {0} {1} -s {2}.{3}.{4}.{5}.{6}\n'.format(                    year_card,                    data_card.mode,                    run.id,                    sequence.id,                    card.id,                    pid,                    all_num,                )		        pid += 1        elif area_tiles and not years:		    for tile in area_tiles:		        tile_card = Tile.objects.get(id=tile.tile_id)		        if run_parallel:			        EXEC = '$RF_EXEC_DIR/PreProc {0} {1} -s {2}.{3}.{4}.{5}.{6}\n'.format(                        tile_card,                        data_card.mode,                        run.id,                        sequence.id,                        card.id,                        pid,                        all_num,                    )			        script_name = '{0}_{1}'.format(card.id, pid)			        EXECUTABLE_DICT[script_name] = EXEC			        create_sub_card_item(script_name, run.id, card.id)			        pid += 1		        else:			        EXECUTABLE += '$RF_EXEC_DIR/PreProc {0} {1} -s {2}.{3}.{4}.{5}.{6}\n'.format(                        tile_card,                        data_card.mode,                        run.id,                        sequence.id,                        card.id,                        pid,                        all_num,                    )			        pid += 1        else:            if run_parallel:                EXEC = '$RF_EXEC_DIR/PreProc {0} -s {1}.{2}.{3}.{4}.{5}\n'.format(                    data_card.mode,                    run.id,                    sequence.id,                    card.id,                    pid,                    all_num,                )                script_name = '{0}_{1}'.format(card.id, pid)                EXECUTABLE_DICT[script_name] = EXEC                create_sub_card_item(script_name, run.id, card.id)            else:                EXECUTABLE += '$RF_EXEC_DIR/PreProc {0} -s {1}.{2}.{3}.{4}.{5}\n'.format(                    data_card.mode,                    run.id,                    sequence.id,                    card.id,                    pid,                    all_num,                )        # write log file        # path_file = '/home/gsi/LOGS/preproc_script.log'        # now = datetime.now()        # log_file = open(path_file, 'a')        # log_file.writelines('{0}\n'.format(now))        # log_file.writelines('CARD PreProc: {0}\n'.format(card_model))        # log_file.writelines('NAME PreProc: {0}\n\n'.format(card.card_item.content_object))        # log_file.writelines('years PreProc: {0}\n\n'.format(years))        # log_file.writelines('EXECUTABLE: {0}\n\n\n'.format(EXECUTABLE))        # log_file.close()    if card_model == 'collate':        # u'Collate <Tile> [<Mode>] [<InpFile>] [<OutDirFile>] [<InpScale>]'        # os.path.join(obj_dir.full_path, f)        from gsi.models import HomeVariables as Home        home_var = Home.objects.all()        root_path = home_var[0].RF_AUXDATA_DIR        # write log file        # path_file = '/home/gsi/LOGS/collate_script.log'        # now = datetime.now()        # log_file = open(path_file, 'a')        # log_file.writelines('====== {0} ==================\n'.format(now))        # log_file.writelines('CARD Collate: {0}\n'.format(card_model))        # log_file.writelines('NAME Collate: {0}\n\n'.format(card.card_item.content_object))        #        files = []        data_card = Collate.objects.get(name=card.card_item.content_object)        area_tiles = get_area_tiles(data_card.area)        files_list = Collate.input_files.through.objects.filter(collate=data_card)        run_parallel = is_run_parallel(data_card)        #        # log_file.writelines('files_list Collate: {0}\n\n'.format(files_list))        #        all_num = len(area_tiles)        for f in files_list:            file_obj = ListTestFiles.objects.get(id=f.listtestfiles_id)            f_name = file_obj.name.split('.')            f_subdir = os.path.join(data_card.output_tile_subdir, f_name[0])            temp = [file_obj.name, f_subdir]            files.append(temp)        if files:            all_num *= len(files)        for tile in area_tiles:            tile_card = Tile.objects.get(id=tile.tile_id)            if files:                for f in files:                    if run_parallel:                        EXEC = '$RF_EXEC_DIR/Collate {0} {1} {2} {3} {4} -s {5}.{6}.{7}.{8}.{9}\n'.format(                            tile_card,                            data_card.mode,                            f[0],                            f[1],                            data_card.input_scale_factor,                            run.id,                            sequence.id,                            card.id,                            pid,                            all_num,                        )                        script_name = '{0}_{1}'.format(card.id, pid)                        EXECUTABLE_DICT[script_name] = EXEC                        create_sub_card_item(script_name, run.id, card.id)                        pid += 1                    else:                        EXECUTABLE += '$RF_EXEC_DIR/Collate {0} {1} {2} {3} {4} -s {5}.{6}.{7}.{8}.{9}\n'.format(                            tile_card,                            data_card.mode,                            f[0],                            f[1],                            data_card.input_scale_factor,                            run.id,                            sequence.id,                            card.id,                            pid,                            all_num,                        )                        pid += 1            else:                if run_parallel:                    EXEC = '$RF_EXEC_DIR/Collate {0} {1} {2} -s {3}.{4}.{5}.{6}.{7}\n'.format(                        tile_card,                        data_card.mode,                        data_card.input_scale_factor,                        run.id,                        sequence.id,                        card.id,                        pid,                        all_num,                    )                    script_name = '{0}_{1}'.format(card.id, pid)                    EXECUTABLE_DICT[script_name] = EXEC                    create_sub_card_item(script_name, run.id, card.id)                    pid += 1                else:                    EXECUTABLE += '$RF_EXEC_DIR/Collate {0} {1} {2} -s {3}.{4}.{5}.{6}.{7}\n'.format(                        tile_card,                        data_card.mode,                        data_card.input_scale_factor,                        run.id,                        sequence.id,                        card.id,                        pid,                        all_num,                    )                    pid += 1		# write log file		# path_file = '/home/gsi/LOGS/collate_script.log'		# now = datetime.now()		# log_file = open(path_file, 'a')		# log_file.writelines('{0}\n'.format(now))		# log_file.writelines('CARD Collate: {0}\n'.format(card_model))		# log_file.writelines('NAME Collate: {0}\n\n'.format(card.card_item.content_object))		# log_file.writelines('Collate area_tiles: {0}\n\n'.format(area_tiles))		# log_file.writelines('Collate files: {0}\n\n'.format(files))		# log_file.writelines('EXECUTABLE: {0}\n\n\n'.format(EXECUTABLE))		# log_file.close()    if card_model == 'randomforest':        # RunRandomForestModels.sh <AoI_Name> <Satellite> <ParamSet> <RunSet>        data_card = RandomForest.objects.get(name=card.card_item.content_object)        EXECUTABLE += 'export MODELDIR=/lustre/w23/mattgsi/satdata/RF/Projects/Models\n'        EXECUTABLE += 'export CSVFILE=/lustre/w23/mattgsi/satdata/RF/Projects/Lane/Data/ref/Model${0}.csv >> $MODELDIR/ParamSet_CSVbands.sh\n'.format(data_card.model)        EXECUTABLE += 'export MVRF_TOTAL={0} >> $MODELDIR/ParamSet_CSV"$XSET".sh\n'.format(data_card.mvrf)        EXECUTABLE += 'RunRandomForestModels.sh {0} {1} {2} {3} -s {4}.{5}.{6}.{7}.{8}\n'.format(            data_card.aoi_name,            data_card.satellite,            data_card.param_set,            data_card.run_set,            run.id,            sequence.id,            card.id,            pid,            1,        )        pid += 1        # print 'randomforest EXECUTABLE ================================ ', EXECUTABLE    if card_model == 'calcstats':        #CalcStats <Tile> [<Year>] [<Period>] [<Filter>] [<FiltOut>] [OutDir]        data_card = CalcStats.objects.get(name=card.card_item.content_object)        period = data_card.period        run_parallel = is_run_parallel(data_card)        if period == 'doy':            period = data_card.doy_variable        try:            years = get_years(data_card.year_group.name)            all_num = len(years)        except Exception, e:            # print 'ERRROR ====================== ', e            years = None        if years:            for year in years:                year_card = Year.objects.get(id=year.year_id)                if run_parallel:                    EXEC = '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} {6} -s {7}.{8}.{9}.{10}.{11}\n'.format(                        data_card.output_tile_subdir,                        year_card,                        period,                        data_card.filter,                        data_card.filter_out,                        data_card.input_fourier,                        data_card.out_dir,                        run.id,                        sequence.id,                        card.id,                        pid,                        all_num                    )                    script_name = '{0}_{1}'.format(card.id, pid)                    EXECUTABLE_DICT[script_name] = EXEC                    create_sub_card_item(script_name, run.id, card.id)                    pid += 1                else:                    EXECUTABLE += '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} {6} -s {7}.{8}.{9}.{10}.{11}\n'.format(                        data_card.output_tile_subdir,                        year_card,                        period,                        data_card.filter,                        data_card.filter_out,                        data_card.input_fourier,                        data_card.out_dir,                        run.id,                        sequence.id,                        card.id,                        pid,                        all_num                    )                    pid += 1        else:            if run_parallel:                EXEC = '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(                    data_card.output_tile_subdir,                    period,                    data_card.filter,                    data_card.filter_out,                    data_card.input_fourier,                    data_card.out_dir,                    run.id,                    sequence.id,                    card.id,                    pid,                    all_num                )                script_name = '{0}_{1}'.format(card.id, pid)                EXECUTABLE_DICT[script_name] = EXEC                create_sub_card_item(script_name, run.id, card.id)                pid += 1            else:                EXECUTABLE += '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(                    data_card.output_tile_subdir,                    period,                    data_card.filter,                    data_card.filter_out,                    data_card.input_fourier,                    data_card.out_dir,                    run.id,                    sequence.id,                    card.id,                    pid,                    all_num                )                pid += 1    # if card_model == 'mergecsv':    #     # MergeCSV <PathSpec>/<FileSpec> [<OutFile>] [<Scale>]    #     data_card = MergeCSV.objects.get(name=card)    #     EXECUTABLE += '$RF_EXEC_DIR/MergeCSV {0} {1} {2} -s {3}.{4}.{5}\n'.format(    #         run.id,    #         card_item.id,    #         pid,    #     )    # print 'EXECUTABLE ================================ ', EXECUTABLE    # print 'EXECUTABLE_DICT ================================ ', EXECUTABLE_DICT    if run_parallel:		card.run_parallel = True		card.number_sub_cards = all_num    elif not run_parallel:		card.run_parallel = False		card.number_sub_cards = 0    card.save()    if run_parallel:	    return run_parallel, EXECUTABLE_DICT    else:	    return run_parallel, EXECUTABLE