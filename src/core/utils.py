# -*- coding: utf-8 -*-import osimport statimport timeimport shutilfrom subprocess import call, Popenfrom datetime import datetimeimport magicimport multiprocessingfrom django.conf import settingsfrom django.utils.translation import ugettext_lazy as _# from django.core.urlresolvers import reverse# from django.shortcuts import get_object_or_404# from django.core.urlresolvers import reverse# from django.http import HttpResponseRedirectfrom gsi.settings import (EXECUTE_FE_COMMAND, PROCESS_NUM,						STATIC_DIR, FE_SUBMIT, EXEC_RUNS)from core.multithreaded import MultiprocessingCardsfrom log.models import LogDebugclass UnicodeNameMixin(object):	def __unicode__(self):		return _(u"%s") % self.namedef validate_status(status):	from gsi.models import STATES	states = [st[0] for st in STATES]	if not status or status not in states:		return {			'status': False,			'message': 'Invalid or missing "status" GET parameter.'		}	return {'status': status}def get_copy_name(name):	if '*cp' in name:		return name.split('*cp')[0]	else:		return namedef execute_fe_command(params, flag='cards'):	# ***********************************************************************	# write log debug execute_fe_command	now = datetime.now()	log_file = '{0}\n'.format(now)	# ***********************************************************************	queue = multiprocessing.JoinableQueue()  # create queue of the tasks	num_process = len(params) / 2	# processes = PROCESS_NUM	processes = num_process	for param in params:		queue.put(param)	for i in xrange(processes):		t = MultiprocessingCards(queue, flag)  # Create process		t.start()		time.sleep(0.1)	queue.join()  # suspend the execution of code until the queue is emptied	# ***********************************************************************	# write log debug execute_fe_command	log_file += 'params = {0}:\n'.format(params)	log_file += 'params LEN = {0}:\n'.format(len(params))	log_file += '\n\n\n'	log_debug = LogDebug.objects.create(		name='execute_fe_command',		log=log_file	)	# ***********************************************************************def slash_remove_from_path(path):	result = path	if '//' in path:		result = path.replace('//', '/')	elif '///' in path:		result = path.replace('///', '/')	return resultdef create_symlink(src, dest, path):	if not os.path.exists(path):		symlink = call("ln -s {0} {1}".format(dest, src), shell=True)	else:		passdef get_dir_root_static_path():	from gsi.models import HomeVariables	home_var = HomeVariables.objects.all()	user_dir_root = home_var[0].USER_DATA_DIR_ROOT	static_dir_root = user_dir_root.split('/')[-1]	if not static_dir_root:		static_dir_root = user_dir_root.split('/')[-2:-1]	static_dir_root_path = STATIC_DIR + '/' + static_dir_root[0]	static_dir_root_path = slash_remove_from_path(static_dir_root_path)	return {		'static_dir_root': static_dir_root[0],		'static_dir_root_path': static_dir_root_path,	}def convert_size_file(size):	kb = 1024.0	mb = 1024.0 * 1024.0	if size < kb:		size_file = "%.2f B" % (size)	if size > mb:		size = size / mb		size_file = "%.2f MB" % (size)	if size > kb:		size = float(size) / kb		size_file = "%.2f KB" % (size)	return size_filedef get_type_file(mime_type):	if mime_type[0] == 'image':		type_file = mime_type[0]	elif mime_type[0] == 'text':		type_file = mime_type[0]	elif mime_type[0] == 'application':		if mime_type[1] == 'pdf':			type_file = mime_type[1]		elif mime_type[1] == 'msword':			type_file = 'doc'		elif mime_type[1] == 'octet-stream':			type_file = 'bin'		else:			type_file = 'archive'	return type_filedef get_files_dirs(url_path, full_path):	dict_dirs = {}	all_dirs = {}	dict_files = {}	all_files = {}	info_message = False	try:		root, dirs, files = os.walk(full_path).next()		for d in dirs:			date_modification = datetime.fromtimestamp(os.path.getmtime(full_path))			format_date_modification = datetime.strftime(date_modification, "%Y/%m/%d %H:%M:%S")			dict_dirs['name'] = d			dict_dirs['date'] = format_date_modification			all_dirs[d] = dict_dirs			dict_dirs = {}		for f in files:			file_path = os.path.join(url_path, f)			full_file_path = os.path.join(full_path, f)			size_file = convert_size_file(os.path.getsize(full_file_path))			date_modification = datetime.fromtimestamp(os.path.getmtime(full_file_path))			format_date_modification = datetime.strftime(date_modification, "%Y/%m/%d %H:%M:%S")			mime_type = magic.from_file(full_file_path, mime=True)			type_file = get_type_file(mime_type.split('/'))			dict_files['name'] = f			dict_files['path'] = file_path			dict_files['size'] = size_file			dict_files['date'] = format_date_modification			dict_files['type'] = type_file			all_files[f] = dict_files			dict_files = {}	except StopIteration, e:		print 'StopIteration ===================== ', e		info_message = True	except OSError, e:		print 'OSError ===================== ', e		info_message = True	return all_dirs, all_files, info_messagedef create_sub_dir(path):	from gsi.models import HomeVariables	home_variables = HomeVariables.objects.all()	path_root = home_variables[0].USER_DATA_DIR_ROOT	sub_directories = ['Results', 'Scores', 'Trees']	try:		path_sub_directories = os.path.join(str(path_root), str(path))		try:			for d in sub_directories:				full_path_sub_directories = os.path.join(str(path_sub_directories), str(d))				os.makedirs(full_path_sub_directories)		except OSError, e:			print '*** FOLDER EXIST ***'	except Exception, e:		print 'ERROR create_sub_dir =================== ', edef create_new_folder(dir):	from gsi.models import HomeVariables as Home	home_var = Home.objects.all()	full_path = os.path.join(home_var[0].RF_AUXDATA_DIR, dir)	try:		os.makedirs(full_path)	except OSError, e:		print '*** FOLDER EXIST ***: ', e	return full_pathdef get_files(path, file_extension):	list_files = []	error = None	try:		root, dirs, files = os.walk(path).next()		list_files = filter(lambda x: x.endswith(file_extension), files)	except StopIteration, e:		print 'StopIteration ===================== ', e		error = e	except OSError, e:		print 'OSError ===================== ', e		error = e	return list_files, errordef update_root_list_files():	from gsi.models import HomeVariables as Home	from gsi.models import ListTestFiles	home_var = Home.objects.all()	root_path = home_var[0].RF_AUXDATA_DIR	try:		# root, dirs, files = os.walk(root_path).next()		files, errors = get_files(root_path, '.tif')		tif_files = filter(lambda x: x.endswith('.tif'), files)		files_exclude = ListTestFiles.objects.filter(input_data_directory=None).exclude(name__in=tif_files).delete()		files_include = ListTestFiles.objects.filter(input_data_directory=None).values_list('name')		for f in tif_files:			file_path = os.path.join(root_path, f)			if (f,) not in files_include:				obj = ListTestFiles.objects.create(name=f, input_data_directory=None)				obj.size = convert_size_file(os.path.getsize(file_path))				obj.date_modified = datetime.fromtimestamp(os.path.getmtime(file_path))				obj.save()			# mime_type = magic.from_file(file_path, mime=True)			# if mime_type == 'image/tiff' and (f,) not in files_include:				# obj = ListTestFiles.objects.create(name=f, input_data_directory=None)			#	 obj.size = convert_size_file(os.path.getsize(file_path))			#	 obj.date_modified = datetime.fromtimestamp(os.path.getmtime(file_path))			#	 obj.save()	except StopIteration, e:		print 'StopIteration ===================== ', e	except OSError, e:		print 'OSError ===================== ', edef update_list_files(obj_dir):	from gsi.models import HomeVariables as Home	from gsi.models import ListTestFiles	update_list_dirs()	home_var = Home.objects.all()	root_path = home_var[0].RF_AUXDATA_DIR	if obj_dir is not None:		full_dir_path = os.path.join(obj_dir.full_path)	else:		full_dir_path = os.path.join(root_path)	try:		root, dirs, files = os.walk(full_dir_path).next()		tif_files = filter(lambda x: x.endswith('.tif'), files)		files_exclude = ListTestFiles.objects.filter(input_data_directory=obj_dir).exclude(name__in=tif_files).delete()		files_include = ListTestFiles.objects.filter(input_data_directory=obj_dir).values_list('name')		for f in tif_files:			full_file_path = os.path.join(full_dir_path, f)			if (f,) not in files_include:				obj = ListTestFiles.objects.create(name=f, input_data_directory=obj_dir)				file_path = os.path.join(full_dir_path, f)				obj.size = convert_size_file(os.path.getsize(file_path))				obj.date_modified = datetime.fromtimestamp(os.path.getmtime(file_path))				obj.save()			# mime_type = magic.from_file(full_file_path, mime=True)			#			# if mime_type == 'image/tiff' and (f,) not in files_include:			#	 obj = ListTestFiles.objects.create(name=f, input_data_directory=obj_dir)			#	 file_path = os.path.join(obj_dir.full_path, f)			#	 obj.size = convert_size_file(os.path.getsize(file_path))			#	 obj.date_modified = datetime.fromtimestamp(os.path.getmtime(file_path))			#	 obj.save()	except StopIteration, e:		print 'StopIteration ===================== ', e	except OSError, e:		print 'OSError ===================== ', edef update_list_dirs():	from gsi.models import InputDataDirectory, ListTestFiles	from gsi.models import HomeVariables as Home	home_var = Home.objects.all()	root_path = home_var[0].RF_AUXDATA_DIR	all_dirs = InputDataDirectory.objects.all()	try:		for dir in all_dirs:			dir_path = os.path.join(root_path, dir.name)			if not os.path.exists(dir_path):				ListTestFiles.objects.filter(input_data_directory=dir).delete()				InputDataDirectory.objects.filter(name=dir.name).delete()	except OSError, e:		print 'OSError ===================== ', edef get_path_folder_run(run):	from gsi.models import HomeVariables as Home	home_var = Home.objects.all()	# home dir scripts	GSI_HOME = settings.SCRIPTS_HOME	path_runs_logs = GSI_HOME + 'scripts/runs/R_{0}/LOGS'.format(run.id)	return path_runs_logsdef copy_file(src, dest, card_name):	message_error = None	err_mess = 'No specification file "PreprocSpec location"'	try:		shutil.copy2(src, dest)	except AttributeError, e:		print('Shutil AttributeError =========================== %s' % e)		message_error = 'For Card "{0}": {1}'.format(card_name, err_mess)	# eg. src and dest are the same file	except shutil.Error as e:		print('Shutil Error =========================== %s' % e)		err_mess = str(e).split(']')[1]		err_mess = err_mess.replace('`', '"')		message_error = 'For Card "{0}": {1}'.format(card_name, err_mess)	# eg. source or destination doesn't exist	except IOError as e:		print('Shutil IOError ========================= %s' % e.strerror)		message_error = 'For Card "{0}": {1}'.format(card_name, err_mess)	return message_errordef create_open_master_script(path_runs, card_id, num):	# ***********************************************************************	# write log debug create_open_master_script	now = datetime.now()	log_file = '{0}\n'.format(now)	# ***********************************************************************	# execute_master_script = {}	num_file = 1	execute_master_script = '{0}_master_{1}'.format(card_id, num)	master_script_name = 'card_{0}_master_{1}.sh'.format(card_id, num)	master_script_path = path_runs + master_script_name	master_script = open(master_script_path, 'w+')	os.chmod(master_script_path, 0777)	# execute_master_script[execute_master] = master_script_path	# ***********************************************************************	# write log debug create_open_master_script	log_file += 'Master Script Name: {0}\n'.format(master_script_name)	log_debug = LogDebug.objects.create(		name='Create Open Master Script',		log=log_file	)	# ***********************************************************************	return master_script, execute_master_scriptdef make_run(run_base, user):	from gsi.models import Run, Log, RunStep, OrderedCardItem, SubCardItem	from gsi.models import HomeVariables as Home	# ***********************************************************************	# write log debug make_run User	now = datetime.now()	log_file = '{0}\n'.format(now)	log_file += 'User: {0}\n'.format(user)	log_debug_user = LogDebug.objects.create(		name='Make Run User',		log=log_file	)	# end write log debug make_run User	# ***********************************************************************	now = datetime.now()	step = RunStep.objects.none()	scripts = []	first_script = {}	path_test_data = ''	message_error = None	run = Run.objects.create(run_base=run_base, user=user)	home_var = Home.objects.all()	resolution = run.run_base.resolution	directory_path = run.run_base.directory_path	all_card = OrderedCardItem.objects.filter(sequence__runbase=run.run_base).order_by('order')	try:		# <USER_DATA_DIR_ROOT>/<resolution>		path_test_data = home_var[0].USER_DATA_DIR_ROOT + '/' + str(resolution) + '/' + str(directory_path) + '/'		path_test_data = path_test_data.replace('//', '/')		# print 'path_test_data ======================== ', path_test_data		try:			os.makedirs(path_test_data, 0777)			# ***********************************************************************			# write log debug make_run make_dirs			now = datetime.now()			log_file = '{0}\n'.format(now)			log_file += 'Make DIRS PATH TESTS: {0}\n\n\n'.format(path_test_data)			log_debug_dir_path_test = LogDebug.objects.create(				name='Make Run Make Dirs',				log=log_file			)			# ***********************************************************************		except OSError, e:			print '*** FOLDER EXIST ***'			print '*** FOLDER EXIST ERROR *** ', e			# ***********************************************************************			# write log debug make_run_OSError			now = datetime.now()			log_file = '{0}\n'.format(now)			log_file += 'OSError PATH TESTS: {0}\n'.format(path_test_data)			log_file += 'OSError ERROR: {0}\n'.format(e)			log_debug_OSError = LogDebug.objects.create(				name='Make Run OSError',				log=log_file			)			# end write log debug make_run_OSError			# ***********************************************************************		finally:			print 'FINALY ============================= '			# ***********************************************************************			# write log debug make_run_Finaly			now = datetime.now()			log_file = '{0}\n'.format(now)			log_file += 'FINALY PATH TESTS: {0}\n'.format(path_test_data)			# path_file = '/home/gsi/LOGS/make_run_Finaly_ERRROR.err'			# now = datetime.now()			# log_file = open(path_file, 'a')			# log_file.writelines('{0}\n'.format(now))			# log_file.writelines('PATH TESTS: {0}\n'.format(path_test_data))			# ***********************************************************************			try:				os.chmod(path_test_data, 0777)				# os.umask(0000)			except Exception, e:				print '*** FOLDER ERROR *** :', e				# ***********************************************************************				# write log debug make_run_Finaly				log_file += 'FINALY ERROR: {0}\n'.format(e)				# ***********************************************************************			# ***********************************************************************			# end write log debug make_run_Finaly			log_debug = LogDebug.objects.create(				name='Make Run Finaly',				log=log_file			)			# ***********************************************************************	except Exception, e:		pass		# ***********************************************************************		# write log debug make_run_ERROR		now = datetime.now()		log_file = '{0}\n'.format(now)		log_file += 'FINALY PATH TESTS: {0}\n'.format(path_test_data)		log_file += 'PATH TESTS: {0}\n'.format(path_test_data)		log_file += 'ERROR: {0}\n'.format(e)		log_debug = LogDebug.objects.create(				name='Make Run ERROR',				log=log_file			)		# end write log debug make_run_ERROR		# ***********************************************************************	for card in all_card:		# ***********************************************************************		# write log debug make_run_cards		now = datetime.now()		log_file = '{0}\n'.format(now)		log_debug_CARDS = LogDebug.objects.create(			name='Make Run CARDS',			log=log_file		)		log_file += 'CARD ==> {0}\n'.format(card)		log_debug_CARDS.update(			name='Make Run CARDS',			log=log_file		)		# ***********************************************************************		step = RunStep.objects.create(parent_run=run, card_item=card)		# ***********************************************************************		log_file += 'STEP ==> {0}\n'.format(step)		log_debug_CARDS.update(			name='Make Run CARDS',			log=log_file		)		# ***********************************************************************		#TODO: make scripts for each step		sequence = step.parent_run.run_base.card_sequence		# ***********************************************************************		log_file += 'SEQUENCE ==> {0}\n'.format(sequence)		log_debug_CARDS.update(			name='Make Run CARDS',			log=log_file		)		# ***********************************************************************		script = create_scripts(run, sequence, card, step)		# ***********************************************************************		log_file += 'SCRIPT ==> {0}\n'.format(script)		log_debug_CARDS.update(			name='Make Run CARDS',			log=log_file		)		# ***********************************************************************		if script['error']:			message_error = script['error']		if not script:			run.delete()			step.delete()			return False		script['step'] = step		scripts.append(script)		# ***********************************************************************		log_file += 'message_error ==> {0}\n'.format(message_error)		log_debug_CARDS.update(			name='Make Run CARDS',			log=log_file		)		# end write log debug make_run_cards		# ***********************************************************************	if scripts:		first_script = scripts[0]		params = []		# ***********************************************************************		# write log debug make_run_scripts		now = datetime.now()		log_file = '{0}\n'.format(now)		log_file += 'SCRIPTS: \n'		log_file += 'name ==> {0}\n'.format(first_script['script_name'])		log_file += 'run ==> {0}\n'.format(first_script['run'].id)		log_debug_SCRIPTS = LogDebug.objects.create(			name='Make Run SCRIPTS',			log=log_file		)		# ***********************************************************************		try:			if first_script['card'].run_parallel:				# sub_card_item = SubCardItem.objects.filter(				# 					run_id=first_script['run'].id,				# 					card_id=first_script['card'].id,				# 					# state='pending'				# 				).order_by('start_date')				# ***********************************************************************				# log_file.writelines('LEN sub_card_item ==> {0}\n'.format(len(sub_card_item)))				# ***********************************************************************				# for card in sub_card_item:				# 	name_card = '{0}%{1}'.format(card.run_id, card.name)				# 	params.append(name_card)					# card.state = 'running'					# card.save()				# execute_fe_command(params)				# print 'master_script_name ============================ ', first_script['master_script_name']				for n in first_script['execute_master_scripts']:					ex_fe_com = Popen(							'nohup {0} {1} {2} &'.format(								EXECUTE_FE_COMMAND,								first_script['run'].id,								n							),							shell=True,						)				first_script['step'].state = 'running'				first_script['step'].save()				first_script['run'].state = 'running'				first_script['run'].save()			else:				ex_fe_com = Popen(					'nohup {0} {1} {2} &'.format(						EXECUTE_FE_COMMAND,						first_script['run'].id,						first_script['card'].id					),					shell=True,				)				first_script['step'].state = 'running'				first_script['step'].save()				first_script['run'].state = 'running'				first_script['run'].save()		except Exception, e:			print 'ERROR ================== ', e			# ***********************************************************************			log_file += 'ERROR make run ==> {0}\n'.format(e)		log_debug_SCRIPTS.update(			name='Make Run SCRIPTS',			log=log_file		)		# end write log debug make_run_scripts		# ***********************************************************************		# print 'EXECUTE_FE_COMMAND ================ ', EXECUTE_FE_COMMAND		# print 'parent_run ================ ', first_script['run'].id		# print 'card_item ================ ', first_script['card'].id		log_name = '{0}_{1}.log'.format(run.id, first_script['card'].id)		path_log = first_script['path_runs_logs']		write_log(log_name, run, path_log)	return {'run': run, 'step': step, 'error': message_error}def create_scripts(run, sequence, card, step):	""" Create a script at startup run_base """	from gsi.models import HomeVariables as Home	card_model = None	message_error = None	execute_master_scripts = []	# ***********************************************************************	# write log debug create_scripts	now = datetime.now()	log_file = '{0}\n'.format(now)	log_file += 'CREATE SCRIPT ==================\n'	log_file += 'RUN ==> {0}; ID ==> {1}\n'.format(run, run.id)	log_file += 'RUN BASE ==> {0}; ID ==> {1}\n'.format(run.run_base, run.run_base.id)	log_file += 'SEQUENCE ==> {0}; ID ==> {1}\n'.format(sequence, sequence.id)	log_file += 'CARD ==> {0}; ID ==> {1}\n'.format(card, card.id)	log_file += 'CARD ITEM ==> {0}; ID ==> {1}\n'.format(step.card_item.card_item, step.card_item.card_item.id)	# ***********************************************************************	home_var = Home.objects.all()	export_home_var = ''	# path_test_data = ''	LOCAL_VAR_GROUPS = ''	# directory_path = run.run_base.directory_path	# home dir scripts	GSI_HOME = settings.SCRIPTS_HOME	# <RESOLUTION_ENV_SCRIPT>	resolution = run.run_base.resolution	RESOLUTION_ENV_SCRIPT = GSI_HOME + 'bin/' + str(resolution) + '_config'	# <HOME_ENV_OVERRIDES>	for hv in home_var:		export_home_var += 'export SAT_TIF_DIR=' + hv.SAT_DIF_DIR_ROOT + '\n'		export_home_var += 'export RF_DIR=' + hv.RF_DIR_ROOT + '\n'		export_home_var += 'export USER_DATA_DIR=' + hv.USER_DATA_DIR_ROOT + '\n'		export_home_var += 'export MODIS_DIR=' + hv.MODIS_DIR_ROOT + '\n'		export_home_var += 'export RF_AUXDATA_DIR=' + hv.RF_AUXDATA_DIR + '\n'		export_home_var += 'export SAT_DIF_DIR=' + hv.SAT_DIF_DIR_ROOT	# <LOCAL_ENV_OVERRIDES>	# ***********************************************************************	log_file += 'LOCAL VAR GROUP ==================\n'	# ***********************************************************************	try:		local_var_groups = (run.run_base.card_sequence.environment_base.environment_variables).replace('\r\n', '\n')		local_var_groups = local_var_groups.splitlines()		LOCAL_VAR_GROUPS = ''		for line in local_var_groups:			if line != '':				ln = line.replace('export ', '')				LOCAL_VAR_GROUPS += u'export {0}\n'.format(ln)		# ***********************************************************************		log_file += 'LOCAL_VAR_GROUPS succes ==> {0}\n'.format(LOCAL_VAR_GROUPS)		# ***********************************************************************	except Exception, e:		LOCAL_VAR_GROUPS = ''		# ***********************************************************************		log_file += 'LOCAL_VAR_GROUPS error ==> {0}\n'.format(e)		# ***********************************************************************	# <ENVIROMENT OVERRIDE>	# ***********************************************************************	log_file += 'ENVIROMENT OVERRIDE ==================\n'	# ***********************************************************************	try:		env_override = (run.run_base.card_sequence.environment_override).replace('\r\n', '\n')		env_override = env_override.splitlines()		ENVIROMENT_OVERRIDE = ''		for line in env_override:			# ***********************************************************************			log_file += 'ENVIROMENT_OVERRIDE LINE ==> {0}\n'.format(line)			# ***********************************************************************			if line != '':				ln = line.replace('export ', '')				ENVIROMENT_OVERRIDE += u'export {0}\n'.format(ln)		# ***********************************************************************		log_file += 'ENVIROMENT_OVERRIDE succes ==> {0}\n'.format(ENVIROMENT_OVERRIDE)		# ***********************************************************************	except Exception, e:		ENVIROMENT_OVERRIDE = ''		# ***********************************************************************		log_file += 'ENVIROMENT_OVERRIDE error ==> {0}\n'.format(e)		# ***********************************************************************	# <EXECUTABLE>	# ***********************************************************************	log_file += 'EXECUTABLE ==================\n'	# ***********************************************************************	try:		card_item = step.card_item.card_item		card_model = card_item.content_type.model		run_parallel, EXECUTABLE = get_executable(run, sequence, card, card_item)		# ***********************************************************************		# print 'run_parallel create_scripts ======================= ', run_parallel		log_file += 'EXECUTABLE succes ==> {0}\n'.format(EXECUTABLE)		# ***********************************************************************	except Exception, e:		print 'ERROR EXECUTABLE ======================= ', e		EXECUTABLE = ''		run_parallel = False		# ***********************************************************************		log_file += 'EXECUTABLE error ==> {0}\n'.format(e)		# ***********************************************************************	# path to scripts for runs and steps	path_runs = GSI_HOME + 'scripts/runs/R_{0}/'.format(run.id)	path_runs_logs = GSI_HOME + 'scripts/runs/R_{0}/LOGS'.format(run.id)	# <USER_DATA_DIR_ROOT>/<resolution>	# ***********************************************************************	# write log file	# path_file = '/home/gsi/LOGS/user.log'	# now = datetime.now()	# log_file = open(path_file, 'a')	# log_file.writelines('{0}\n'.format(now))	log_file += 'USER {0}\n'.format(os.getlogin())	# ***********************************************************************	try:		os.makedirs(path_runs)		os.makedirs(path_runs_logs)		# os.umask(0000)	except OSError, e:		print '*** FOLDER EXIST ***'		# ***********************************************************************		log_file += 'ERROR {0}\n\n\n'.format(e)		log_file += 'ERROR path_runs {0}\n\n\n'.format(path_runs)		log_file += 'ERROR path_runs_logs {0}\n\n\n'.format(path_runs_logs)		# ***********************************************************************	finally:		try:			# import pdb;pdb.set_trace()			# print 'MAKE RUN CARD ================== ', step.card_item			# print 'MAKE RUN PARALLEL ================== ', (not run_parallel)			if card_model == 'preproc' or card_model == 'calcstats':				card_name = card.card_item.content_object				cur_card = get_card_model(card_model, card_name)				from_path_spec_location = cur_card.path_spec_location				to_path_spec_location = path_runs				message_error = copy_file(from_path_spec_location, to_path_spec_location, card_name)			if run_parallel:				# print 'YES PARALLEL ================== ', run_parallel				params = []				num_file = 1				count = 0				# master_script_name = 'card_{0}_master_{1}.sh'.format(card.id, num_file)				# master_script_path = path_runs + master_script_name				# master_script = open(master_script_path, 'w+')				# execute_master = '{0}_master'.format(card.id)				master_script, execute_master = create_open_master_script(path_runs, card.id, num_file)				execute_master_scripts.append(execute_master)				for n in EXECUTABLE:					file_contents = ''					script_name = 'card_{0}.sh'.format(n)					script_path = path_runs + script_name					card_line = '{0} {1} {2}\n'.format(FE_SUBMIT, run.id, n)					execute_runs = count % EXEC_RUNS					if not execute_runs and count:						num_file += 1						master_script.close()						# os.chmod(master_script_path, 0777)						master_script, execute_master = create_open_master_script(path_runs, card.id, num_file)						execute_master_scripts.append(execute_master)						# master_script_name = 'card_{0}_master_{1}.sh'.format(card.id, num_file)					master_script.write(card_line)					file_contents += '# Sequence: {0}, card: {1} - Generated {2}\n\n'.\										format(sequence.name, card.card_item, step.start_date)					file_contents += 'umask 000\n\n'					file_contents += 'cd {0}\n\n'.format(path_runs)					file_contents += '. ' + RESOLUTION_ENV_SCRIPT + '\n\n'					file_contents += export_home_var + '\n\n'					file_contents += LOCAL_VAR_GROUPS + '\n\n'					file_contents += ENVIROMENT_OVERRIDE + '\n\n'					file_contents += EXECUTABLE[n]					fd = open(script_path, 'w+')					fd.write(file_contents)					# os.chmod(script_path, 0777)					# os.chmod(path_runs_logs, 0777)					fd.close()					os.chmod(script_path, 0777)					os.chmod(path_runs_logs, 0777)					count += 1					# os.umask(0000)					# fd.write('# Sequence: {0}, card: {1} - Generated {2} \n\n'.\					#		  format(sequence.name, card.card_item, step.start_date))					# fd.writelines('. ' + RESOLUTION_ENV_SCRIPT + '\n\n')					# fd.writelines(export_home_var + '\n\n')					# fd.writelines(LOCAL_VAR_GROUPS + '\n\n')					# fd.writelines(ENVIROMENT_OVERRIDE + '\n\n')					# fd.writelines(EXECUTABLE[n])					#					# os.chmod(script_path, 0777)					# os.chmod(path_runs_logs, 0777)					# fd.close()				master_script.close()				# os.chmod(master_script_path, 0777)				# 	param = '{0}%{1}%{2}'.format(script_path, path_runs_logs, file_contents)				# 	params.append(param)				# execute_fe_command(params, flag='file')			else:				# print 'NOT PARALLEL ================== ', run_parallel				script_name = 'card_{0}.sh'.format(step.card_item.id)				script_path = path_runs + script_name				fd = open(script_path, 'w+')				fd.write('# Sequence: {0}, card: {1} - Generated {2} \n\n'.\						 format(sequence.name, card.card_item, step.start_date))				fd.writelines('umask 000\n\n')				fd.writelines('cd {0}\n\n'.format(path_runs))				fd.writelines('. ' + RESOLUTION_ENV_SCRIPT + '\n\n')				fd.writelines(export_home_var + '\n\n')				fd.writelines(LOCAL_VAR_GROUPS + '\n\n')				fd.writelines(ENVIROMENT_OVERRIDE + '\n\n')				fd.writelines(EXECUTABLE)				os.chmod(script_path, 0777)				os.chmod(path_runs_logs, 0777)				# os.umask(0000)				fd.close()				# print 'NOT PARALLEL ================== ', run_parallel		except OSError, e:			pass			# ***********************************************************************			log_file += 'OSError {0}\n\n\n'.format(e)			# ***********************************************************************			return False	# ***********************************************************************	log_debug = LogDebug.objects.create(		name='Create Scripts',		log=log_file	)	# end write log debug create_scripts	# ***********************************************************************	return {		'script_path': script_path,		'path_runs_logs': path_runs_logs,		'script_name': script_name,		# 'card': card_item.id,		'run': run,		'card': card,		'error': message_error,		'execute_master_scripts': execute_master_scripts	}def write_log(log_name, run, path_log):	from gsi.models import Log	log = Log.objects.create(name=log_name)	log.log_file_path = path_log	log.log_file = log_name	log.save()	run.log = log	run.save()def get_years(name):	from gsi.models import YearGroup	year_group = YearGroup.objects.get(name=name)	return year_group.years.through.objects.filter(yeargroup=year_group)def get_area_tiles(name):	from gsi.models import Area	card_area = Area.objects.get(name=name)	return card_area.tiles.through.objects.filter(area=card_area)def get_statistical_method(remap_obj):	stat_methods = []	if remap_obj.conditional_mean:		stat_methods.append('ConditionalMean')	if remap_obj.conditional_min:		stat_methods.append('ConditionalMin')	if remap_obj.conditional_median:		stat_methods.append('ConditionalMedian')	if remap_obj.conditional_max:		stat_methods.append('ConditionalMax')	if remap_obj.lower_quartile:		stat_methods.append('LowerQuartile')	if remap_obj.upper_quartile:		stat_methods.append('UpperQuartile')	return stat_methodsdef get_card_model(card_model, card_name):	from cards.models import (RFScore, RFTrain, QRF,							  Remap, YearFilter, PreProc,							  Collate, MergeCSV, RandomForest,							  CalcStats)	card = None	if card_model == 'rfscore':		card = RFScore.objects.get(name=card_name)	if card_model == 'rftrain':		card = RFTrain.objects.get(name=card_name)	if card_model == 'qrf':		card = QRF.objects.get(name=card_name)	if card_model == 'remap':		card = Remap.objects.get(name=card_name)	if card_model == 'yearfilter':		card = YearFilter.objects.get(name=card_name)	if card_model == 'preproc':		card = PreProc.objects.get(name=card_name)	if card_model == 'collate':		card = Collate.objects.get(name=card_name)	if card_model == 'randomforest':		card = RandomForest.objects.get(name=card_name)	if card_model == 'calcstats':		card = CalcStats.objects.get(name=card_name)	return carddef is_run_parallel(card):	run_parallel = False	try:		run_parallel = card.run_parallel	except Exception:		pass	return run_paralleldef create_sub_card_item(name, run_id, card_id):	from gsi.models import SubCardItem	try:		sub_card_item = SubCardItem.objects.create(				name=name,				run_id=run_id,				card_id=card_id		)	except Exception, e:		print 'ERROR sub card ======================== ', edef get_executable(run, sequence, card, card_item):	"""get the <EXECUTABLE> to script."""	from cards.models import (RFScore, RFTrain, QRF,							Remap, YearFilter, PreProc,							Collate, MergeCSV, RandomForest,							CalcStats)	from gsi.models import Year, Tile, ListTestFiles	card_model = card_item.content_type.model	# name_card = step.card_item.card_item.content_object	# run_parallel = False	# EXECUTABLE = ''	EXECUTABLE = ''	EXECUTABLE_DICT = {}	EXEC = ''	pid = 1	all_num = 1	run_parallel = False	# write log file	# path_file = '/home/gsi/LOGS/card_create_script.log'	# now = datetime.now()	# log_file = open(path_file, 'a')	# log_file.writelines('{0}\n'.format(now))	# log_file.writelines('CARD MODEL: {0}\n'.format(card_model))	# log_file.writelines('CARD NAME: {0}\n\n\n'.format(card.card_item.content_object))	# log_file.close()	if card_model == 'rfscore':		#  u'RFscore <Tile> [[MyDir]] [<BiasCorrn>] [<QRFopts>] [<RefTarget>] [<CleanName>]'		data_card = RFScore.objects.get(name=card.card_item.content_object)		years = get_years(data_card.year_group.name)		area_tiles = get_area_tiles(data_card.area)		all_num = len(years) * len(area_tiles)		run_parallel = is_run_parallel(data_card)		# write log file		# path_file = '/home/gsi/LOGS/rfscore_script.log'		# now = datetime.now()		# log_file = open(path_file, 'a')		# log_file.writelines('{0}\n'.format(now))		# log_file.writelines('CARD RFTrain: {0}\n'.format(card_model))		# log_file.writelines('NAME RFTrain: {0}\n\n\n'.format(card.card_item.content_object))		# log_file.writelines('--------------------')		#		# log_file.writelines('YEARS: {0}\n'.format(len(years)))		# log_file.writelines('AREAS: {0}\n'.format(len(area_tiles)))		# log_file.writelines('ALL NUM: {0}\n\n\n'.format(all_num))		# log_file.close()		for year in years:			year_card = Year.objects.get(id=year.year_id)			for tile in area_tiles:				tile_card = Tile.objects.get(id=tile.tile_id)				# print 'PID RFscore ====================== ', pid				if run_parallel:					EXEC = '$RF_EXEC_DIR/RFscore {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(						tile_card,						run.run_base.directory_path,						data_card.bias_corrn,						year_card,						data_card.number_of_threads,						data_card.QRFopts,						run.id,						sequence.id,						card.id,						pid,						all_num					)					script_name = '{0}_{1}'.format(card.id, pid)					EXECUTABLE_DICT[script_name] = EXEC					create_sub_card_item(script_name, run.id, card.id)					pid += 1				else:					EXECUTABLE += '$RF_EXEC_DIR/RFscore {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(						tile_card,						run.run_base.directory_path,						data_card.bias_corrn,						year_card,						data_card.number_of_threads,						data_card.QRFopts,						run.id,						sequence.id,						card.id,						pid,						all_num					)					pid += 1	if card_model == 'rftrain':		# u'RFtrain <Tile> [<Ntrees>] [<training>] [<Nvar>] [<Nthread>]'		data_card = RFTrain.objects.get(name=card.card_item.content_object)		# run_parallel = is_run_parallel(data_card)		# write log file		# path_file = '/home/gsi/LOGS/rftrain_script.log'		# now = datetime.now()		# log_file = open(path_file, 'a')		# log_file.writelines('{0}\n'.format(now))		# log_file.writelines('CARD RFTrain: {0}\n'.format(card_model))		# log_file.writelines('NAME RFTrain: {0}\n\n\n'.format(card.card_item.content_object))		# log_file.writelines('VALUE: {0}\n'.format(data_card.value))		# log_file.writelines('TREES: {0}\n'.format(data_card.number_of_trees))		# log_file.writelines('VARIABLE: {0}\n'.format(data_card.number_of_variable))		# log_file.writelines('TREAD: {0}\n'.format(data_card.number_of_thread))		# log_file.close()		EXECUTABLE += '$RF_EXEC_DIR/RFtrain {0} {1} {2} {3} {4} -s {5}.{6}.{7}.{8}.{9}\n'.format(			data_card.value,			data_card.number_of_trees,			data_card.training,			data_card.number_of_variable,			data_card.number_of_thread,			run.id,			sequence.id,			card.id,			pid,			1)		pid += 1	if card_model == 'qrf':		# u'QRF [<QRFinterval>] [<ntrees>] [<nthreads>] [<MyDir>]'		data_card = QRF.objects.get(name=card.card_item.content_object)		EXECUTABLE += '$RF_EXEC_DIR/QRF {0} {1} {2} {3} -s {4}.{5}.{6}.{7}.{8}\n'.format(							data_card.interval,							data_card.number_of_trees,							data_card.number_of_threads,							data_card.directory,							run.id,							sequence.id,							card.id,							pid,							1,						)		pid += 1	if card_model == 'remap':		# import pdb;pdb.set_trace()		# print 'remap =================== '		# u'Remap <FileSpec> <RoI> <OutRoot>[,<OutSuffix>] [<ColourTable>] [<RefStatsFile>] [<RefStatsScale>]'		# Remap <FileSpec> <RoI> <OutRoot>[,<OutSuffix>] [<Scale>[,<Xsize>,<Ysize>]] [<Output>] [<ColourTable>] [<RefStatsFile>] [<RefStatsScale>]		years = None		data_card = Remap.objects.get(name=card.card_item.content_object)		# print 'data_card =================== ', data_card		stat_methods = get_statistical_method(data_card)		# print 'stat_methods =================== ', stat_methods		run_parallel = is_run_parallel(data_card)		# print 'remap run_parallel ====================== ', run_parallel		model_name_suff = ''		file_spec = data_card.file_spec		output_root = data_card.output_root		refstats_scale = data_card.refstats_scale or ''		all_num = 1		if data_card.model_name and data_card.output_suffix:			model_name_suff = str(data_card.model_name) + data_card.output_suffix		if data_card.model_name and not data_card.output_suffix:			model_name_suff = str(data_card.model_name)		if not data_card.model_name and data_card.output_suffix:			model_name_suff = data_card.output_suffix		if data_card.year_group is not None:			years = get_years(data_card.year_group.name)		if years is not None:			years_num = len(years) or 1			methods_num = len(stat_methods) or 1			all_num = years_num * methods_num			for year in years:				year_card = Year.objects.get(id=year.year_id)				if stat_methods:					for m in stat_methods:						if model_name_suff:							method_file_spec = str(year_card) + '_' + m + '_' + model_name_suff						else:							method_file_spec = str(year_card) + '_' + m						method = str(year_card) + '_' + m						cur_file_spec = os.path.join(str(file_spec), method_file_spec)						cur_output_root = os.path.join(str(output_root), method)						if run_parallel:							# print 'remap parrallel =============================='							EXEC = '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(								cur_file_spec,								data_card.roi,								cur_output_root,								# data_card.output_suffix,								data_card.scale,								data_card.output,								data_card.color_table,								data_card.refstats_file,								refstats_scale,								run.id,								sequence.id,								card.id,								pid,								all_num,							)							script_name = '{0}_{1}'.format(card.id, pid)							EXECUTABLE_DICT[script_name] = EXEC							create_sub_card_item(script_name, run.id, card.id)							pid += 1						else:							EXECUTABLE += '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(								cur_file_spec,								data_card.roi,								cur_output_root,								# data_card.output_suffix,								data_card.scale,								data_card.output,								data_card.color_table,								data_card.refstats_file,								refstats_scale,								run.id,								sequence.id,								card.id,								pid,								all_num,							)							pid += 1				else:					if model_name_suff:						full_path = str(year_card) + '_' + model_name_suff						cur_file_spec = os.path.join(str(file_spec), full_path)					else:						cur_file_spec = os.path.join(str(file_spec), str(year_card))					cur_output_root = os.path.join(str(output_root), str(year_card))					if run_parallel:						EXEC = '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(							cur_file_spec,							data_card.roi,							cur_output_root,							# data_card.output_suffix,							data_card.scale,							data_card.output,							data_card.color_table,							data_card.refstats_file,							refstats_scale,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						script_name = '{0}_{1}'.format(card.id, pid)						EXECUTABLE_DICT[script_name] = EXEC						create_sub_card_item(script_name, run.id, card.id)						pid += 1					else:						EXECUTABLE += '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(							cur_file_spec,							data_card.roi,							cur_output_root,							# data_card.output_suffix,							data_card.scale,							data_card.output,							data_card.color_table,							data_card.refstats_file,							refstats_scale,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						pid += 1		else:			if stat_methods:				all_num = len(stat_methods)				for m in stat_methods:					if model_name_suff:						full_path = m + '_' + model_name_suff						cur_file_spec = os.path.join(str(file_spec), full_path)					else:						cur_file_spec = os.path.join(str(file_spec), m)					cur_output_root = os.path.join(str(output_root), m)					if run_parallel:						EXEC = '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(							cur_file_spec,							data_card.roi,							cur_output_root,							# data_card.output_suffix,							data_card.scale,							data_card.output,							data_card.color_table,							data_card.refstats_file,							refstats_scale,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						script_name = '{0}_{1}'.format(card.id, pid)						EXECUTABLE_DICT[script_name] = EXEC						create_sub_card_item(script_name, run.id, card.id)						pid += 1					else:						EXECUTABLE += '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(							cur_file_spec,							data_card.roi,							cur_output_root,							# data_card.output_suffix,							data_card.scale,							data_card.output,							data_card.color_table,							data_card.refstats_file,							refstats_scale,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						pid += 1			else:				if model_name_suff:					cur_file_spec = os.path.join(str(file_spec), model_name_suff)				else:					# cur_file_spec = os.path.join(str(file_spec), "Scores")					cur_file_spec = str(file_spec)				if run_parallel:					EXEC = '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(						cur_file_spec,						data_card.roi,						data_card.output_root,						# data_card.output_suffix,						data_card.scale,						data_card.output,						data_card.color_table,						data_card.refstats_file,						refstats_scale,						run.id,						sequence.id,						card.id,						pid,						1,					)					script_name = '{0}_{1}'.format(card.id, pid)					EXECUTABLE_DICT[script_name] = EXEC					create_sub_card_item(script_name, run.id, card.id)					pid += 1				else:					EXECUTABLE += '$RF_EXEC_DIR/Remap {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(						cur_file_spec,						data_card.roi,						data_card.output_root,						# data_card.output_suffix,						data_card.scale,						data_card.output,						data_card.color_table,						data_card.refstats_file,						refstats_scale,						run.id,						sequence.id,						card.id,						pid,						1,					)					pid += 1	if card_model == 'yearfilter':		# u'YearFilter <Tile> <FileType> [<Filter>] [<FiltOut>] [<ExtendStart>] [<InpFourier>] [<OutDir>] [<InpDir>]'		data_card = YearFilter.objects.get(name=card.card_item.content_object)		area_tiles = get_area_tiles(data_card.area)		all_num = len(area_tiles)		run_parallel = is_run_parallel(data_card)		for tile in area_tiles:			tile_card = Tile.objects.get(id=tile.tile_id)			if run_parallel:				EXEC = '$RF_EXEC_DIR/YearFilter {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(					tile_card,					data_card.filetype,					data_card.filter,					data_card.filter_output,					data_card.extend_start,					data_card.input_fourier,					data_card.output_directory,					data_card.input_directory,					run.id,					sequence.id,					card.id,					pid,					all_num,				)				script_name = '{0}_{1}'.format(card.id, pid)				EXECUTABLE_DICT[script_name] = EXEC				create_sub_card_item(script_name, run.id, card.id)				pid += 1			else:				EXECUTABLE += '$RF_EXEC_DIR/YearFilter {0} {1} {2} {3} {4} {5} {6} {7} -s {8}.{9}.{10}.{11}.{12}\n'.format(					tile_card,					data_card.filetype,					data_card.filter,					data_card.filter_output,					data_card.extend_start,					data_card.input_fourier,					data_card.output_directory,					data_card.input_directory,					run.id,					sequence.id,					card.id,					pid,					all_num,				)				pid += 1	if card_model == 'preproc':		# print 'preproc ===================== '		# print 'preproc card ===================== ', card		# print 'preproc card ID ===================== ', card.id		# u'PreProc [<Tile>|<file.hdf>] [<Year>] [<Mode>]'		data_card = PreProc.objects.get(name=card.card_item.content_object)		years = None		area_tiles = None		if data_card.year_group:			years = get_years(data_card.year_group.name)		if data_card.area:			area_tiles = get_area_tiles(data_card.area)		run_parallel = is_run_parallel(data_card)		if years:			len_years = len(years)		else:			len_years = 1		if area_tiles:			len_area_tiles = len(area_tiles)		else:			len_area_tiles = 1		all_num = len_years * len_area_tiles		if run_parallel:			card.run_parallel = True			card.number_sub_cards = all_num			card.save()		if years and area_tiles:			for year in years:				year_card = Year.objects.get(id=year.year_id)				for tile in area_tiles:					tile_card = Tile.objects.get(id=tile.tile_id)					if run_parallel:						EXEC = '$RF_EXEC_DIR/PreProc {0} {1} {2} -s {3}.{4}.{5}.{6}.{7}\n'.format(							tile_card,							year_card,							data_card.mode,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						script_name = '{0}_{1}'.format(card.id, pid)						EXECUTABLE_DICT[script_name] = EXEC						create_sub_card_item(script_name, run.id, card.id)						pid += 1					else:						EXECUTABLE += '$RF_EXEC_DIR/PreProc {0} {1} {2} -s {3}.{4}.{5}.{6}.{7}\n'.format(							tile_card,							year_card,							data_card.mode,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						pid += 1		if years and not area_tiles:			if run_parallel:				EXEC = '$RF_EXEC_DIR/PreProc {0} {1} -s {2}.{3}.{4}.{5}.{6}\n'.format(					year_card,					data_card.mode,					run.id,					sequence.id,					card.id,					pid,					all_num,				)				script_name = '{0}_{1}'.format(card.id, pid)				EXECUTABLE_DICT[script_name] = EXEC				create_sub_card_item(script_name, run.id, card.id)				pid += 1			else:				EXECUTABLE += '$RF_EXEC_DIR/PreProc {0} {1} -s {2}.{3}.{4}.{5}.{6}\n'.format(					year_card,					data_card.mode,					run.id,					sequence.id,					card.id,					pid,					all_num,				)				pid += 1		elif area_tiles and not years:			for tile in area_tiles:				tile_card = Tile.objects.get(id=tile.tile_id)				if run_parallel:					EXEC = '$RF_EXEC_DIR/PreProc {0} {1} -s {2}.{3}.{4}.{5}.{6}\n'.format(						tile_card,						data_card.mode,						run.id,						sequence.id,						card.id,						pid,						all_num,					)					script_name = '{0}_{1}'.format(card.id, pid)					EXECUTABLE_DICT[script_name] = EXEC					create_sub_card_item(script_name, run.id, card.id)					pid += 1				else:					EXECUTABLE += '$RF_EXEC_DIR/PreProc {0} {1} -s {2}.{3}.{4}.{5}.{6}\n'.format(						tile_card,						data_card.mode,						run.id,						sequence.id,						card.id,						pid,						all_num,					)					pid += 1		else:			if run_parallel:				EXEC = '$RF_EXEC_DIR/PreProc {0} -s {1}.{2}.{3}.{4}.{5}\n'.format(					data_card.mode,					run.id,					sequence.id,					card.id,					pid,					all_num,				)				script_name = '{0}_{1}'.format(card.id, pid)				EXECUTABLE_DICT[script_name] = EXEC				create_sub_card_item(script_name, run.id, card.id)			else:				EXECUTABLE += '$RF_EXEC_DIR/PreProc {0} -s {1}.{2}.{3}.{4}.{5}\n'.format(					data_card.mode,					run.id,					sequence.id,					card.id,					pid,					all_num,				)		# write log file		# path_file = '/home/gsi/LOGS/preproc_script.log'		# now = datetime.now()		# log_file = open(path_file, 'a')		# log_file.writelines('{0}\n'.format(now))		# log_file.writelines('CARD PreProc: {0}\n'.format(card_model))		# log_file.writelines('NAME PreProc: {0}\n\n'.format(card.card_item.content_object))		# log_file.writelines('years PreProc: {0}\n\n'.format(years))		# log_file.writelines('EXECUTABLE: {0}\n\n\n'.format(EXECUTABLE))		# log_file.close()	if card_model == 'collate':		# u'Collate <Tile> [<Mode>] [<InpFile>] [<OutDirFile>] [<InpScale>]'		# os.path.join(obj_dir.full_path, f)		from gsi.models import HomeVariables as Home		home_var = Home.objects.all()		root_path = home_var[0].RF_AUXDATA_DIR		# write log file		# path_file = '/home/gsi/LOGS/collate_script.log'		# now = datetime.now()		# log_file = open(path_file, 'a')		# log_file.writelines('====== {0} ==================\n'.format(now))		# log_file.writelines('CARD Collate: {0}\n'.format(card_model))		# log_file.writelines('NAME Collate: {0}\n\n'.format(card.card_item.content_object))		#		files = []		data_card = Collate.objects.get(name=card.card_item.content_object)		area_tiles = get_area_tiles(data_card.area)		files_list = Collate.input_files.through.objects.filter(collate=data_card)		run_parallel = is_run_parallel(data_card)		#		# log_file.writelines('files_list Collate: {0}\n\n'.format(files_list))		#		all_num = len(area_tiles)		for f in files_list:			file_obj = ListTestFiles.objects.get(id=f.listtestfiles_id)			f_name = file_obj.name.split('.')			f_subdir = os.path.join(data_card.output_tile_subdir, f_name[0])			temp = [file_obj.name, f_subdir]			files.append(temp)		if files:			all_num *= len(files)		for tile in area_tiles:			tile_card = Tile.objects.get(id=tile.tile_id)			if files:				for f in files:					if run_parallel:						EXEC = '$RF_EXEC_DIR/Collate {0} {1} {2} {3} {4} -s {5}.{6}.{7}.{8}.{9}\n'.format(							tile_card,							data_card.mode,							f[0],							f[1],							data_card.input_scale_factor,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						script_name = '{0}_{1}'.format(card.id, pid)						EXECUTABLE_DICT[script_name] = EXEC						create_sub_card_item(script_name, run.id, card.id)						pid += 1					else:						EXECUTABLE += '$RF_EXEC_DIR/Collate {0} {1} {2} {3} {4} -s {5}.{6}.{7}.{8}.{9}\n'.format(							tile_card,							data_card.mode,							f[0],							f[1],							data_card.input_scale_factor,							run.id,							sequence.id,							card.id,							pid,							all_num,						)						pid += 1			else:				if run_parallel:					EXEC = '$RF_EXEC_DIR/Collate {0} {1} {2} -s {3}.{4}.{5}.{6}.{7}\n'.format(						tile_card,						data_card.mode,						data_card.input_scale_factor,						run.id,						sequence.id,						card.id,						pid,						all_num,					)					script_name = '{0}_{1}'.format(card.id, pid)					EXECUTABLE_DICT[script_name] = EXEC					create_sub_card_item(script_name, run.id, card.id)					pid += 1				else:					EXECUTABLE += '$RF_EXEC_DIR/Collate {0} {1} {2} -s {3}.{4}.{5}.{6}.{7}\n'.format(						tile_card,						data_card.mode,						data_card.input_scale_factor,						run.id,						sequence.id,						card.id,						pid,						all_num,					)					pid += 1		# write log file		# path_file = '/home/gsi/LOGS/collate_script.log'		# now = datetime.now()		# log_file = open(path_file, 'a')		# log_file.writelines('{0}\n'.format(now))		# log_file.writelines('CARD Collate: {0}\n'.format(card_model))		# log_file.writelines('NAME Collate: {0}\n\n'.format(card.card_item.content_object))		# log_file.writelines('Collate area_tiles: {0}\n\n'.format(area_tiles))		# log_file.writelines('Collate files: {0}\n\n'.format(files))		# log_file.writelines('EXECUTABLE: {0}\n\n\n'.format(EXECUTABLE))		# log_file.close()	if card_model == 'randomforest':		# RunRandomForestModels.sh <AoI_Name> <Satellite> <ParamSet> <RunSet>		data_card = RandomForest.objects.get(name=card.card_item.content_object)		EXECUTABLE += 'export MODELDIR=/lustre/w23/mattgsi/satdata/RF/Projects/Models\n'		EXECUTABLE += 'export CSVFILE=/lustre/w23/mattgsi/satdata/RF/Projects/Lane/Data/ref/Model${0}.csv >> $MODELDIR/ParamSet_CSVbands.sh\n'.format(data_card.model)		EXECUTABLE += 'export MVRF_TOTAL={0} >> $MODELDIR/ParamSet_CSV"$XSET".sh\n'.format(data_card.mvrf)		EXECUTABLE += 'RunRandomForestModels.sh {0} {1} {2} {3} -s {4}.{5}.{6}.{7}.{8}\n'.format(			data_card.aoi_name,			data_card.satellite,			data_card.param_set,			data_card.run_set,			run.id,			sequence.id,			card.id,			pid,			1,		)		pid += 1		# print 'randomforest EXECUTABLE ================================ ', EXECUTABLE	if card_model == 'calcstats':		#CalcStats <Tile> [<Year>] [<Period>] [<Filter>] [<FiltOut>] [OutDir]		data_card = CalcStats.objects.get(name=card.card_item.content_object)		period = data_card.period		run_parallel = is_run_parallel(data_card)		if period == 'doy':			period = data_card.doy_variable		try:			years = get_years(data_card.year_group.name)			# years_num = len(years)		except Exception, e:			# print 'ERRROR ====================== ', e			years_num = 1			years = None		try:			areas = get_area_tiles(data_card.area.name)			# areas_num = len(areas)		except Exception, e:			# print 'ERRROR ====================== ', e			areas_num = 1			areas = None		if years and areas:			all_num = len(years) * len(areas)			# print 'YEAR ======================= ', len(years)			# print 'AREA ======================= ', len(areas)			# print 'ALL ======================= ', all_num			for year in years:				year_card = Year.objects.get(id=year.year_id)				for area in areas:					# area_card = Area.objects.get(id=year.year_id)					area_card = Tile.objects.get(id=area.tile_id)					if run_parallel:						EXEC = '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} {6} -s {7}.{8}.{9}.{10}.{11}\n'.format(							# data_card.output_tile_subdir,							area_card,							year_card,							period,							data_card.filter,							data_card.filter_out,							data_card.input_fourier,							data_card.out_dir,							run.id,							sequence.id,							card.id,							pid,							all_num						)						script_name = '{0}_{1}'.format(card.id, pid)						EXECUTABLE_DICT[script_name] = EXEC						create_sub_card_item(script_name, run.id, card.id)						pid += 1					else:						EXECUTABLE += '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} {6} -s {7}.{8}.{9}.{10}.{11}\n'.format(							# data_card.output_tile_subdir,							area_card,							year_card,							period,							data_card.filter,							data_card.filter_out,							data_card.input_fourier,							data_card.out_dir,							run.id,							sequence.id,							card.id,							pid,							all_num						)						pid += 1		elif years and not areas:			all_num = len(years)			for year in years:				year_card = Year.objects.get(id=year.year_id)				if run_parallel:					EXEC = '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(						# data_card.output_tile_subdir,						year_card,						period,						data_card.filter,						data_card.filter_out,						data_card.input_fourier,						data_card.out_dir,						run.id,						sequence.id,						card.id,						pid,						all_num					)					script_name = '{0}_{1}'.format(card.id, pid)					EXECUTABLE_DICT[script_name] = EXEC					create_sub_card_item(script_name, run.id, card.id)					pid += 1				else:					EXECUTABLE += '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(						# data_card.output_tile_subdir,						year_card,						period,						data_card.filter,						data_card.filter_out,						data_card.input_fourier,						data_card.out_dir,						run.id,						sequence.id,						card.id,						pid,						all_num					)					pid += 1		elif not years and areas:			all_num = len(areas)			for area in areas:				area_card = Tile.objects.get(id=area.tile_id)				if run_parallel:					EXEC = '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(						# data_card.output_tile_subdir,						area_card,						period,						data_card.filter,						data_card.filter_out,						data_card.input_fourier,						data_card.out_dir,						run.id,						sequence.id,						card.id,						pid,						all_num					)					script_name = '{0}_{1}'.format(card.id, pid)					EXECUTABLE_DICT[script_name] = EXEC					create_sub_card_item(script_name, run.id, card.id)					pid += 1				else:					EXECUTABLE += '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(						# data_card.output_tile_subdir,						area_card,						period,						data_card.filter,						data_card.filter_out,						data_card.input_fourier,						data_card.out_dir,						run.id,						sequence.id,						card.id,						pid,						all_num					)					pid += 1		else:			if run_parallel:				EXEC = '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(					data_card.output_tile_subdir,					period,					data_card.filter,					data_card.filter_out,					data_card.input_fourier,					data_card.out_dir,					run.id,					sequence.id,					card.id,					pid,					all_num				)				script_name = '{0}_{1}'.format(card.id, pid)				EXECUTABLE_DICT[script_name] = EXEC				create_sub_card_item(script_name, run.id, card.id)				pid += 1			else:				EXECUTABLE += '$RF_EXEC_DIR/CalcStats {0} {1} {2} {3} {4} {5} -s {6}.{7}.{8}.{9}.{10}\n'.format(					data_card.output_tile_subdir,					period,					data_card.filter,					data_card.filter_out,					data_card.input_fourier,					data_card.out_dir,					run.id,					sequence.id,					card.id,					pid,					all_num				)				pid += 1	# if card_model == 'mergecsv':	#	 # MergeCSV <PathSpec>/<FileSpec> [<OutFile>] [<Scale>]	#	 data_card = MergeCSV.objects.get(name=card)	#	 EXECUTABLE += '$RF_EXEC_DIR/MergeCSV {0} {1} {2} -s {3}.{4}.{5}\n'.format(	#		 run.id,	#		 card_item.id,	#		 pid,	#	 )	# print 'EXECUTABLE ================================ ', EXECUTABLE	# print 'EXECUTABLE_DICT ================================ ', EXECUTABLE_DICT	if run_parallel:		card.run_parallel = True		card.number_sub_cards = all_num	elif not run_parallel:		card.run_parallel = False		card.number_sub_cards = 0	card.save()	if run_parallel:		# print 'EXECUTABLE_DICT =================== ', EXECUTABLE_DICT		# print 'PARALLEL =================== ', run_parallel		return run_parallel, EXECUTABLE_DICT	else:		# print 'EXECUTABLE =================== ', EXECUTABLE		# print 'PARALLEL =================== ', run_parallel		return run_parallel, EXECUTABLE